var documenterSearchIndex = {"docs":
[{"location":"concepts/fundamentals/#Fundamentals","page":"Fundamentals","title":"Fundamentals","text":"This page describes some of the fundamental ideas on which RetrievalToolbox is built on. New users are strongly encouraged to read through the following list of items, as it will hopefully clarify how this software is meant to be used.","category":"section"},{"location":"concepts/fundamentals/#Overview","page":"Fundamentals","title":"Overview","text":"RetrievalToolbox is not a retrieval algorithm. The software library provides types from which objects can be created. These objects represent concepts that are commonly used in many retrieval (and related) applications and algorithms. RetrievalToolbox also provides many functions that use these objects to perform various calculations. Overall, the different object types and functions are designed to be part of a user-written application with the aim to produce modelled radiances as viewed by a hyperspectral-type spectroscopic instrument.\n\nUsers are required to write their own applications (forward models) to make use of RetrievalToolbox's capabilities. To make this initial step easier for new users, the main Github page has links to tutorials as well as example implementations that showcase how RetrievalToolbox can be used to build relevant applications.","category":"section"},{"location":"concepts/fundamentals/#Details","page":"Fundamentals","title":"Details","text":"","category":"section"},{"location":"concepts/fundamentals/#How-to-Build-a-Retrieval-Algorithm","page":"Fundamentals","title":"How to Build a Retrieval Algorithm","text":"This section here will illustrate how the software library is designed to be used in order to build a retrieval algorithm. Note that the emphasis is on \"illustrate\" (the code below does will not run), since even the most basic retrieval algorithm requires a moderate amount of set-up and arranging of the appropriate inputs.\n\nAt the most basic level, users must provide the following components to build a simple retrieval algorithm: a solver object, a state vector, and a forward model. The forward model may be any user-defined function that takes only the state vector object (see State Vector Types) as its mandatory argument, along with any optional keyword arguments. It also must return a Bool (true or false), since the solver routines check whether the forward model was executed successfully or not.\n\n# Load the module\nusing RetrievalToolbox; const RE = RetrievalToolbox\n\nfunction forward_model!(\n    sv::RE.AbstractStateVector;\n    rad::RE.Radiance, jac::RE.Radiance)::Bool\n    # .. calculate instrument-level observation based on `sv`\n    #    and store the result in `rad`, Jacobians in `jac`\n    return true\nend\n\nThe exclamation mark in the function name is a Julia naming convention and signifies that the function is expected to alter (mutate) one or more of the function arguments. RetrievalToolbox has no further requirements regarding the function itself, users may add any number of keyword arguments to control the execution of their forward model function as long as the state vector sv is the first and only non-keyword argument.\n\nNext, we must build a solver object. We will use the iterative maximum a-posteriori inversion scheme, which maximizes the posterior probability distribution in the Bayesian sense, given some prior constraint.\n\nsolver = RE.IMAPSolver(\n    forward_model!, # Our forward model defined above\n    sv, # The state vector [NOT DEFINED IN THIS EXAMPLE]\n    Sa, # The prior covariance matrix [NOT DEFINED IN THIS EXAMPLE]\n    10, # Number of iterations before we give up\n    1.0, # Δσ² factor to control convergence\n    dispersions, # Dispersion objects [NOT DEFINED IN THIS EXAMPLE]\n    indices, # Which indices in the placeholder does each window utilize? [NOT DEFINED IN THIS EXAMPLE]\n    radiance, # Radiance array for current iteration (must be the same we use in `forward_model!`)\n    jacobians, # Jacobian placeholder [NOT DEFINED IN THIS EXAMPLE]\n    measurement, # The instrument-level observation we want to match [NOT DEFINED IN THIS EXAMPLE]\n    noise # The instrument-level noise-equivalent radiance [NOT DEFINED IN THIS EXAMPLE]\n)\n\nAs is evident in the above code snippet, even the most basic set-up would require a handful of quantities to be created before they can be ingested into the new solver object. For the sake of keeping this section short, we will skip that for now.\n\nNow the only thing left to do is to call the function that performs the iterations. To manually take a step in the inversion, we can simply write:\n\nRE.next_iteration!(solver; fm_kwargs=(rad=radiance,jac=jacobians))\n\nThe next_iteration! function takes our solver object and performs a step to minimize the cost function (see Rodgers 2000, Chapter 4). As long as we have done everything correctly, which mostly means that the Jacobians are calculated correctly, the state vector sv will be adapted such that re-running the forward model will yield a result that better matches the observation (in our case, the supplied: measurement).\n\nWhen building a retrieval algorithm, our task is thus the following:\n\nCollect all required inputs from the various data sources (L1B, auxiliary files, instrument parameters, climatology, ..) and prepare them into the appropriate containers. Radiance measurements must be copied into Radiance-type arrays, dispersion objects and noise level vectors must be created in accordance to instrument specifications.\nCreate a state vector that reflects the character of the retrieval problem, and set appropriate prior and first-guess values, along with reasonable values for prior covariance.\nWrite a forward model function that computes the instrument-level radiance to be compared against a measurement. This function must not only calculate the radiances, but also the partial derivatives of the radiances with respect to each state vector element.\nInitialize a solver using the various objects we just described and iterate with the provided function until a satisfactory outcome is obtained.","category":"section"},{"location":"concepts/fundamentals/#Example:-Fitting-a-line-with-RetrievalToolbox","page":"Fundamentals","title":"Example: Fitting a line with RetrievalToolbox","text":"It may be helpful to review the ideas of the preceding section through an actual example that can be run. In the following example, we will handle a contrived situation in which we try to fit a line through a number of points. This example has no meaningful equivalent in the world of atmospheric trace gas retrievals, but one could think of measuring a linear, spectral illumination gradient with a detector that is subject to random noise. We will create a forward model that simply produces y = kcdot x + d, where y represents the modeled radiance.\n\nThe following code snippets can be executed, so users may copy the contents into an active Julia session or notebook and run them! Note that users might need to install additional packages into their Julia environment to make this work properly.\n\nFirst, a few modules need to be loaded, including the RetrievalToolbox itself along with some others that provide plotting capability.\n\n# Load needed packages\nusing RetrievalToolbox; const RE = RetrievalToolbox\n\nusing LinearAlgebra\nusing Plots; default(titlefontsize=10, labelfontsize=8)\nusing Random\nusing Unitful\n\nIn the next step, we define now many points we want to produce in this example that we want to fit later on. Readers may adjust this number, and the following code will adjust to the new value accordingly.\n\nN_point = 15; # Number of points in the example\n\nnothing # hide\n\nFor this example, we make a choice for our ficticious instrument, which shall cover the spectral wavelength range between 0 µm and 1 µm, and calculate the point spacing based on the number N_points which was defined above.\n\nFurther, we also create two important objects that define our instrument. The SpectralWindow object, which sets the extent and resolution of our model calculations. We set the lower and upper bounds, and create a model grid simply based on the spacing. As per requirement of the SpectralWindow, our model grid has to include points beyond the desired spectral bounds, so we add one point on either side to fulfil that requirement. The SimplePolynomialDispersion object (see also: Core Concepts) is then needed to let the software know how spectral samples (e.g. detector pixels) translate to wavelengths.\n\nspacing = 1.0 / (N_point - 1) # Calculate point spacing\n\n# Create spectral window object\nswin = RE.SpectralWindow(\n    \"example_window\", # plain-text name for future reference\n    0.0, # Lower wavelength bound\n    1.0, # Upper wavelength bound\n    0. - spacing:spacing:1.0 + spacing |> collect, # the underlying high-resolution grid\n    u\"µm\", # The wavelength unit to be used\n    0.0 # The reference wavelength for spectrally dependent quantities (e.g. slopes)\n)\n\n# Create dispersion object, linked to spectral window above\ndisp = RE.SimplePolynomialDispersion(\n    [0.0, 1.0/N_point] * u\"µm\", # polynomial coefficients, in ascending order\n    0:N_point - 1,\n    swin\n)\n\nnothing # hide\n\nThis is all we need for our simple example: we have created a dispersion disp that defines a linear dispersion with following coefficients:\n\ndisp\n\nNow it is time to define our state vector, the quantity that controls the evaluation of our forward model. In order to fit a line through some points, we can luckily make use of a pre-existing structure: the zero-level offset. In real atmospheric trace gas retrievals, the zero-level offset (ZLO) can be a handy element to model radiance that is additive to all other radiance calculations. It can be used as a low-order approximation to parasitic stray light, for example. For our example, it is highly convenient, since it can produce a line to fit some points.\n\nIn order to do so, we go ahead and create two state vector elements, one for the offset at zero (d), and one for the slope (k). We then combine those two into a vector and create the RetrievalStateVector object. State vector elements in RetrievalToolbox have to be initialized with some parameters that define their prior and first-guess values, as well as their (Gaussian) prior covariance. This particular type of state vector element, called ZeroLevelOffsetPolynomialSVE, also requires to be attached to a SpectralWindow, since the software allows different ZLOs to be calculated for different spectral windows separately.\n\nzlo0 = RE.ZeroLevelOffsetPolynomialSVE(\n    swin, # Spectral window\n    0, # Coefficient order\n    u\"µm\", # Spectral unit\n    1.0, # Radiance unit\n    0.0, # First guess\n    0.0, # Prior value\n    1.0 # Prior covariance\n)\n\nzlo1 = RE.ZeroLevelOffsetPolynomialSVE(\n    swin, # Spectral window\n    1, # Coefficient order\n    u\"µm\", # Spectral unit\n    1.0, # Radiance unit\n    1.0, # First guess\n    1.0, # Prior value\n    1.0 # Prior covariance\n)\n\nsv = RE.RetrievalStateVector([zlo0, zlo1])\n\nThe following step creates a buffer object, which is needed to hold various quantities from a calculation. Details are not yet important here, it is sufficient to know that RetrievalToolbox makes heavy use of pre-allocated arrays to minimize the number of allocations that would otherwise slow down the processing of many measurements.\n\nrt_buf = RE.ScalarRTBuffer(\n    Dict(swin => disp),\n    RE.ScalarRadiance(Float64, N_point),\n    Dict(sve => RE.ScalarRadiance(Float64, N_point) for sve in sv.state_vector_elements),\n    Dict(swin => Int[]),\n    1.0\n);\n\nnothing # hide\n\nAs mentioned before, one of the most crucial parts of a RetrievalToolbox implementation is the user-defined forward model. In this exercise, we can reduce the forward model to four simple function calls:\n\nWe first calculate the mapping between spectral window/dispersion and the radiance buffer[1].\nWe make sure that there is no previous result stored still in the rt_buf.radiance array, so we zero it out.\nWe calculate the radiances by adding the contributions y = y + d and then y = y + kcdot x.\nWe then calculate the Jacobians (partial derivatives) partial y  partial d = 1 and partial y  partial k = x.\n\nNote that both radiance and derivatives are calculated automatically by the appropriate functions inside of RetrievalToolbox, so we do not need to write them explicitly.\n\n[1]: This is a required bookkeeping step; when more than one spectral window is used, there is no single obvious choice regarding where the radiance results of any given spectral window should be stored in the pre-allocated buffer. The calculate_indices! function makes sure that this assignment is available via the rt_buf.indices field.\n\nfunction forward_model!(\n        sv::RE.AbstractStateVector;\n        rt_buf::RE.ScalarRTBuffer\n        )::Bool\n\n    # Need this to calculate index positions to move from\n    # dispersion -> buffer array\n    RE.calculate_indices!(rt_buf, [swin]) # Step (1)\n\n    # Zero out radiance container!\n    rt_buf.radiance[:] .= 0 # Step (2)\n\n    # Calculates the radiances in rt_buf.radiance by adding them to\n    # the existing values. This is essentially our `y = y + k*x + d`\n    for sve in sv.state_vector_elements\n        RE.apply_radiance_correction!(rt_buf, sve) # Step (3)\n    end\n\n    # Calculates the Jacobians in rt_buf.jacobians;\n    # the partial derivatives w.r.t. `k` and `d`; ∂y/∂k=x and ∂y/∂d=1\n    for sve in sv.state_vector_elements\n        RE.calculate_jacobian!(rt_buf, sve) # Step (4)\n    end\n\n    # Forward model functions must return either true or false. If they return false,\n    # further steps in the inversion process are not executed.\n    return true\n\nend\n\nIt is now time to create our synthetic \"measurement\", a series of points along a line, that we also perturb a little according to some chosen noise level. The cell below defines a few constants from which we calculate our points through which we will then fit a line. Feel free to change these values! Larger values for σ will produce a more noisy measurement and the resulting fit will be worse.\n\nσ = 0.1; # Noise level\nk = 1.2345 # The true slope\nd = -0.4567 # The true offset at zero\n\nnothing # hide\n\n# Creates a wavelength, which we can use as the `x` in our `y = k * x + d`\n_, x = calculate_grid_from_dispersion(disp, swin)\n\n# Calculate the synthetic measurement (without noise)\nmeas_true = k .* x .+ d;\n# Add some noise by sampling a normal distribution and scale it by our noise `σ`\nRandom.seed!(1) # Make sure this is reproducible\nmeas_noisy = meas_true[:] .+ randn(size(meas_true)) .* σ;\n\n# Create the theoretical noise, which is the expected per-pixel standard deviation\nnoise_eq_rad = fill(σ, size(meas_noisy));\n\nnothing # hide\n\nWe can now assemble the solver object with all the components that we created.\n\n\nsolver = RE.IMAPSolver(\n    forward_model!, # Our forward model defined above\n    sv, # The state vector\n    Diagonal(RE.get_prior_covariance(sv)), # The (diagonal) prior covariance matrix\n    -1, # Number of iterations before we give up (not used here)\n    0.0, # Δσ² factor to control convergence (not used here)\n    Dict(swin => disp), # Dispersion objects\n    rt_buf.indices, # Which indices in the placeholder does each window utilize?\n    rt_buf.radiance, # Radiance array\n    rt_buf.jacobians, # Jacobian placeholder\n    Dict(disp => meas_noisy), # The instrument-level observation we want to match\n    Dict(disp => noise_eq_rad) # The instrument-level noise σ\n);\n\nnothing # hide\n\nThe following steps perform the inversion. Since this is a fully linear problem, meaning that the derivatives do not depend on the state vector itself, the solution is found in exactly one single step. We call on the IMAP solver to perform that one iteration via next_iteration! and then once more evaluate the forward model such that the model radiance is calculated with the updated state vector and store in rt_buf.radiance.\n\n# Re-set the state vector (not needed, but helpful if this code is run multiple times)\nRE.reset!(sv)\n# Perform the next step (this updates the state vector!)\nRE.next_iteration!(solver; fm_kwargs=(rt_buf=rt_buf,))\n# Evaluate the forward model with the updated state vector\nsolver.forward_model(solver.state_vector; rt_buf=rt_buf)\n\nnothing # hide\n\nPlot the results! Note that we make use of the get_measured, get_modeled and get_wavelength helper functions which let us extract those quantities without us having to think too much about indices and buffers. RetrievalToolbox has many of these helper functions which compactify a lot of tasks that might otherwise be typed out very often.\n\nscatter(RE.get_wavelength(solver), RE.get_measured(solver), label=\"Noisy measurement\")\nplot!(RE.get_wavelength(solver), meas_true, label=\"Truth\", marker=:square, markersize=3)\nplot!(RE.get_wavelength(solver), RE.get_modeled(solver), label=\"fit\", linestyle=:dash, width=3)\nxlims!(-0.1, 1.1)\nPlots.savefig(\"linefit_fig1.svg\"); closeall(); nothing # hide\n\n(Image: line fit plot)\n\nWe can see in the plot that best-fit line (thick dashed line, green) as compared to the truth (thin line, squares, orange) before application of the noise (noisy data are the blue circles).\n\nRetrievalToolbox does not only provide means for fitting a model to measurements. Since many of the quantities in the inversion process persist in memory until explicitly deleted by users, one can easily do error analysis for example. The below function prints a summary of the posterior state vector, including the best-fit values for our offset at zero d (ZeroLevelOffsetPolynomialSVE (0)) and the slope k (ZeroLevelOffsetPolynomialSVE (1)), along with the theoretical uncertainties on those values. Compare the values shown there to the ones initially picked to produce the synthetic measurement!\n\nRE.print_posterior(solver)","category":"section"},{"location":"concepts/fundamentals/#Mutability-of-Objects","page":"Fundamentals","title":"Mutability of Objects","text":"In scientific computing, many objects (think mostly: arrays) are mutable. This is also true in RetrievalToolbox, where mutable objects are used throughout the software library. Mutability refers to the fact that values can change after initialization. In general, mutability makes it more difficult to read or understand program code as one has to track how and if object values change throughout the program runtime.\n\nThe main advantage of mutability is the single reason why it is used heavily in RetrievalToolbox: modifying objects in-place leads to significant performance gain since we can re-use already created objects rather than having to re-allocate them in memory. Think of an object that represents the per-layer optical properties due to gas absorption, which may be an array with 30,000 rows and 25 columns. If we set up a pipeline where we want to perform retrievals for an entire orbit's worth of scenes, we would have to create this array potentially hundreds of thousands of times. In Julia, we also cannot manually de-allocate unneeded objects, so these arrays would remain in memory until a garbage collector sweep removes them. If we treat that array as a re-usable container, however, we need to allocate it only once and then fill it with meaningful values when needed.\n\nThis choice comes with the obvious downside that it is possible to alter the contents of objects in a way that is not meaningful in the context of a retrieval algorithm. For example, referring back to the section above we can easily edit the contents of the dispersion object disp without seeing an error raised or any other complaints:\n\ndisp.index[1] = min(10, N_point - 1)\n\nIf we were to attempt to fit the line again, we would see somewhat unpredicted behavior, since we now changed how the instrument model relates detector-level spectral samples to those spectral points within our desired spectral window.\n\nRE.reset!(sv)\nRE.next_iteration!(solver; fm_kwargs=(rt_buf=rt_buf,))\nsolver.forward_model(solver.state_vector; rt_buf=rt_buf)\n\nscatter(RE.get_wavelength(solver), RE.get_measured(solver), label=\"Noisy measurement\")\nplot!(RE.get_wavelength(solver), meas_true, label=\"Truth\", marker=:square, markersize=3)\nplot!(RE.get_wavelength(solver), RE.get_modeled(solver), label=\"fit\", linestyle=:dash, width=3)\nxlims!(-0.1, 1.1)\nPlots.savefig(\"linefit_fig2.svg\"); closeall(); nothing # hide\n\n(Image: line fit plot)\n\nIn Julia, native arrays and arrays that derive from the native abstract array type, are always mutable, therefore users will always be able to modify array-type fields of any RetrievalToolbox type objects.\n\nwarning: Warning\nMany objects in RetrievalToolbox are mutable, and therefore can be altered after they have been initialized. This is deliberately part of the software design and intended behavior as it allows highly performant retrieval pipelines in which objects are re-used. Users must always aim to write their code carefully to avoid unwanted and accidental modifications of objects and to be diligent about how and when to modify objects.","category":"section"},{"location":"concepts/fundamentals/#Utilizing-Buffers","page":"Fundamentals","title":"Utilizing Buffers","text":"As part of the \"mutability paradigm\", RetrievalToolbox employs so-called buffers. One can think of them as structured containers that include correctly-sized arrays. These buffers are to be allocated ahead of running the actual forward model calculations or the retrieval. Several crucial functions in RetrievalToolbox explicitly require some buffer type object, hence the use of these buffers is not optional.\n\nA typical workflow for a retrieval problem, in which we want to perform gas retrievals for many scenes, could look like the following:\n\nCreate atmospheric constituents (gases, aerosols)\nCreate spectral window(s) and dispersion(s) for the range(s) of interest\nCreate state vector elements and collect them into a state vector\nCreate the buffer(s) (requires the objects from 1-3)\nWrite forward model function\nCreate a solver object (using all of the above)\nLoop through scenes\nCopy measurement of the current scene into solver (overwriting!)\nAdjust prior and first guess values of the state vector, then re-set state vector (overwriting!)\nCopy atmospheric data (meteorology, gas profiles etc.) into buffer (overwriting!)\nRun inversion until convergence is reached\nCopy state vector contents into some appropriate collection to store per-scene results\nRepeat until all scenes are processed\n\nDetails on the different buffer types are found at Buffer types.","category":"section"},{"location":"concepts/fundamentals/#Units","page":"Fundamentals","title":"Units","text":"Physical units are used within RetrievalToolbox to make sure that necessary unit conversions are performed when needed. Many objects will require an explicit unit to be supplied during construction, and most objects require specific units that match the quantity. This generally allows users to mix and match compatible units and choose whichever units are more convenient for some particular use case. For example, the volume mixing ratio for CO₂ may be stated in ppm, whereas the mixing ratio for CH₄ could be stated in ppb. The internal routines inside RetrievalToolbox perform the appropriate conversions when needed.\n\nFor example, when creating a state vector element that controls the surface pressure, users must supply a pressure-type unit, such as Pa, hPa or Torr.\n\nusing Unitful\nusing RetrievalToolbox; const RE = RetrievalToolbox\n\nsve_psurf = RE.SurfacePressureSVE(\n    u\"hPa\", # unit\n    1000.0, # first guess\n    1000.0, # prior value\n    400.0 # prior covariance\n)\n\nUsing an incompatible unit will throw an error:\n\nsve_psurf = RE.SurfacePressureSVE(\n    u\"km\", # WILL NOT WORK: km is not compatible with a unit of type kg m⁻¹ s⁻²\n    1000.0, # first guess\n    1000.0, # prior value\n    400.0 # prior covariance\n)\n\nNote that the use of units is not fully automatic, users must be aware of where unit information is stored in the various objects. Let us think of a situation where two spectral windows are present, swin1 and swin2:\n\nusing Unitful\nusing RetrievalToolbox; const RE = RetrievalToolbox\n\nswin1 = RE.SpectralWindow(\n    \"window1\", # plain-text name for future reference\n    1.5, # Lower wavelength bound\n    1.7, # Upper wavelength bound\n    1.4:0.1:1.8 |> collect, # the underlying high-resolution grid\n    u\"µm\", # The wavelength unit to be used\n    1.6 # The reference wavelength for spectrally dependent quantities (e.g. slopes)\n)\n\nswin2 = RE.SpectralWindow(\n    \"window2\", # plain-text name for future reference\n    800., # Lower wavelength bound\n    900., # Upper wavelength bound\n    780.:1.:910. |> collect, # the underlying high-resolution grid\n    u\"nm\", # The wavelength unit to be used\n    850. # The reference wavelength for spectrally dependent quantities (e.g. slopes)\n)\n\nnothing # hide\n\nNote that swin1 uses µm, and swin2 uses nm. If we wanted to find out which of those two windows is lower in spectral space, we may instinctively write something like this:\n\nswin1.ww_min < swin2.ww_max\n\nThe result above, true, suggests that indeed the lower bound of swin1 is lower than the lower bound of swin2. That is, of course, not true when accounting for the fact that the wavelength values inside of swin1 are in µm, and those within swin2 are in nm. Users must write the following instead:\n\nswin1.ww_min * swin1.ww_unit < swin2.ww_min * swin2.ww_unit\n\nMultiplying a value with a Unitful unit produces a quantity with an attached physical unit, and the comparison will respect the units (if compatible) and produce the correct answer.\n\nTo learn more about units and how they are used in RetrievalToolbox, follow this link: working with units.","category":"section"},{"location":"concepts/fundamentals/#Reading-material","page":"Fundamentals","title":"Reading material","text":"Most concepts in RetrievalToolbox assume a general understanding of trace gas remote sensing. Here is a list of useful literature that may help those who are new to this research area:\n\nDifferential Optical Absorption Spectroscopy, Platt & Stutz, 2008, Springer: a thorough text book on the DOAS retrieval technique, introduces all the required concepts starting from the fundamental physics that lead to molecular absorption features.\nNovel Methods for Atmospheric Carbon Dioxide Retrieval from the JAXA GOSAT and NASA OCO-2 Satellites, Somkuti, 2018, PhD Thesis: a thesis with a focus on satellite remote sensing of CO₂ and radiative transfer acceleration techniques.\nInverse Methods for Atmospheric Sounding, Rodgers, 2000, World Scientific Publishing: the de-facto standard textbook for optimal-estimation type inversions in the context of atmospheric retrievals.\nToward Urban Greenhouse Gas Mapping with a Portable Reflected Sunlight Spectrometer, Löw, 2024, PhD Thesis: contains very useful chapters on the theory and operation of FTIR spectrometers as well as chapers on retrievals (4.3 onwards).\nOCO-2/3 L2 Algorithm Theoretical Basis Document: details the concepts used in the operational full-physics type retrieval algorithm for NASA's OCO-2 and OCO-3 missions.\nESA GHG-CCI+ Algorithm Theoretical Basis Documents: scroll down to see the ATBDs for the participating algorithms for the ESA GHG-CCI+ project.","category":"section"},{"location":"concepts/radiance/#Working-with-radiance-types","page":"Radiance","title":"Working with radiance types","text":"There are, at the moment, two radiance types that users can utilize to store calculated or measured radiance: ScalarRadiance and VectorRadiance. Both very similar to generic arrays, in fact they inherit many of the properties and functions from Julia's arrays.\n\nDepending on the situation, users can work with ScalarRadiance when polarization does not need to be accounted for, or use the VectorRadiance type if polarization is needed. Note that as opposed to many other types, these radiance containers do not have a unit field, but that might change in future versions.\n\nThe main idea is to use whichever type is most natural for the specific application. While it would have been possible to only use a single radiance type which considers all components of the Stokes vector, it would require users to pay attention to Stokes components Q and U without ever truly needing them.\n\nBoth ScalarRadiance and VectorRadiance have only one field, named S which itself is the underlying array of some type T to store the radiance. For ScalarRadiance, S is a vector (intensity I only), and VectorRadiance, S is a 3-column array representing the I, Q and U components. Both radiance types possess appropriate accessor functions so users can use the more \"natural\" I, Q, U notation to access the Stokes components in addition to simply using the type field .S.","category":"section"},{"location":"concepts/radiance/#Basic-examples","page":"Radiance","title":"Basic examples","text":"For a very basic example, let us first generate some scalar radiance object using the internal constructor.\n\nusing RetrievalToolbox # hide\nconst RE = RetrievalToolbox # hide\nT = Float64;\nN = 4;\ns = RE.ScalarRadiance(T, N)\n\ns is now our radiance object, which only has one field, namely S, representing the intensity for some number of spectral indices.\n\nSimilarly, we can create a vector radiance that represents the first three components of the Stokes vector:\n\nv = RE.VectorRadiance(T, N)\n\nFunctions that manipulate radiance can easily access the Stokes components inside either s or v via the explicit dot syntax.\n\ns.I[:] .= 0.1;\nv.I[:] .= 0.2;\nv.Q[:] .= -0.3;\nv.U[:] .= 0.03;\n\nThe main reason why the underlying object .S is an Array/Vector-type for both is to facilitate highly performant operations. For now, RetrievalToolbox makes use of LoopVectorization.jl, which speeds up certain looped computations dramatically, and we can easily use e.g. the @turbo macro to wrap such loops. Having both radiance types look similar under the hood allows users to write fast functions that are agnostic to the type of radiance, and thus work for either. Yet, it is still possible to dispatch on a particular radiance type, so that specific calculations can be done according to whether some radiance object is a ScalarRadiance or a VectorRadiance\n\nFor example, let's write a function that simply doubles all components of a radiance object:\n\nusing LoopVectorization\n\nfunction double_rad!(r::Radiance)\n    @turbo for i in axes(r, 1) # Loop over spectral points\n        for j in axes(r, 2) # Loop over components (if applicable)\n            r.S[i,j] *= 2\n        end\n    end\nend\n\ndouble_rad!(s)\nshow(s)\ndouble_rad!(v)\nshow(v)\n\nNote the following: first, we make sure that this function is only to be used on radiance types, so we use the Radiance type (which is simply a union between ScalarRadiance and VectorRadiance) to restrict the function argument r. Then, we write a @turbo-accelerated loop that stretches over two dimensions of r. Even for the one-dimensional scalar radiance s, a second dimension is accessible as long as that second dimension is accessed by the index [1], trying to access another index will lead to a BoundsError. Lastly we do not simply write r[i,j] *= 2, but explicitly state the underlying array object r.S and write r.S[i,j] *= 2. While both versions would work in this case, the @turbo macro would not be able to produce accelerated code if we omit the .S.\n\nnote: Note\nWhen writing code to perform operations on or with some radiance object r, best performance is achieved when explicitly using the underlying array object r.S.\n\nThe ability to write a two-dimensional loop body even for the one-dimensional scalar radiance is crucial and allows users to write radiance type-agnostic code. Mixing two radiance objects of different radiance type is also easy to do, but requires some more checks on the possible types. Note that as a conscious design decision, there are currently no arithmetic operations defined on radiance objects of different types, so users will have to explicitly write those operations. While one can perform e.g. additions on two radiance objects of the same type, operations on different types will generally fail.\n\nFor example, the following works without issues\n\ns + s\n\nv - 2*v\n\nThis next example, however, will fail since the shapes are incompatible:\n\nshow(size(s))\nshow(size(v))\ns + v\n\nWhen it so happens that two or more radiance objects have to be used in mathematical operations, a few simple checks can be done to make sure that compatible operations are performed.\n\nnew_rad = VectorRadiance(T, N); # T,N from above..\nr1 = s; r2 = v; # or can use r1 = v; r2 = s;\n\n@views new_rad[:,1] = r1[:,1] + r2[:,1]; # Add intensity component (both have them)\n\nif r1 isa VectorRadiance\n@views new_rad[:,2:end] += r1[:,2:end]\nend\n\nif r2 isa VectorRadiance\n@views new_rad[:,2:end] += r2[:,2:end]\nend\nnew_rad\n\nIn general, the expectation is that users tend to know which radiance objects are vector radiances, and which ones are scalar radiances, so it should generally be possible to write explicit and performant code when e.g. scalar solar (ir)radiances are multiplied with top-of-atmosphere vector radiances. For rare cases where the type is not known, type checks like above can be used to make sure the operations will succeed regardless of the type.","category":"section"},{"location":"concepts/core_concepts/#core_concepts","page":"Core Concepts","title":"Core Algorithm Concepts","text":"note: Note\nWithin the RetrievalToolbox algorithm tools, an attempt is made to keep notation consistent as well as stick to more modern terminology. This approach occasionally overrides more antiquated terms, so various sections in the documentation will emphasize when a possible clash is expected.","category":"section"},{"location":"concepts/core_concepts/#Instrument-Spectral-Response-Function-(formerly-ILS)","page":"Core Concepts","title":"Instrument Spectral Response Function (formerly ILS)","text":"OCO ATBD","category":"section"},{"location":"concepts/core_concepts/#Pixels,-Spectral-Samples-and-Dispersion","page":"Core Concepts","title":"Pixels, Spectral Samples and Dispersion","text":"The distinction between pixels, samples and what dispersion describes occasionally causes confusion due to a lack of consistent terminology in publications or other various documents.\n\nA pixel is considered to be a discrete unit on an instrument detector of any type (where appropriate). Some instruments aggregate pixels during the read-out process such that the data received does not truly reflect the physical detector elements. Other instruments do read out the detector on a native pixel level, however some form of processing is performed afterwards and the resulting data, as ingested by retrieval algorithms, can no longer considered to be per-pixel.\n\nRetrieval algorithms, in general, act on calibrated, geo-located radiance data, often denoted as Level-1b (L1B, L1b). For hyperspectral data, there usually is at least one spectral dimension of that data such that when the data is extracted along that dimension, one obtains what is considered a spectrum. One spectrum thus has a discrete number of elements along its spectral axis and the spectral axis consists of spectral samples. Those spectral samples do not have to be identical with the underlying detector pixels. For most instruments, they are not. Even for instruments in which the detector pixels map 1:1 into spectral samples, it is a good choice to stay consistent in the terminology and refer to an element of a spectrum as spectral sample.\n\nFor a single spectrum I that is extracted from calibrated, geo-located radiance data, the spectral sample information can be written explicitly as I_s, with s being some index of its spectral dimension. I_s is naturally a discrete quantity with s being a discrete index itself. Compare this to a theoretical description of radiance, which in general is a continuous function of wavelength or wavenumber tildeI(lambda) or tildeI(nu). In order to allow for a comparison between measured quantity I_s and a model radiance, one must know which wavelength or wavenumber corresponds to a spectral sample at index s.\n\nThe relationship between spectral sample (index) and wavelength or wavenumber is usually called dispersion. An alternative term for dispersion is wavelength (wavenumber) solution. It is some general function d which maps a spectral sample index to either wavelength or wavenumber, whichever is appropriate for the specific instrument: d(s) = lambda_s or d(s) = nu_s. When d is known, it is straightforward to evaluate some continuous function tildeI at the correct wavelength or wavenumber in order to compare it to a measured value: I_s sim tildeIleft( d(s) right).\n\nFor many instruments, the function d is generally smooth and tends to be expressed as a polynomial which maps spectral sample to wavelength or wavenumber in the following way:\n\n    lambda_s = sum_i=0^N c_i cdot s^i \n\nor\n\n    nu_s = sum_i=0^N c_i cdot s^i\n\nThe polynomial coefficients c are usually either available in the published measurement data, in accompanying documents, or in rare cases, have to be derived.\n\nDispersions in RetrievalToolbox are implemented under the abstract type umbrella of AbstractDispersion, and the type documentation can be found here: dispersion types.","category":"section"},{"location":"functions/state_vector_functions/#State-Vector-Functions","page":"State Vector Functions","title":"State Vector Functions","text":"","category":"section"},{"location":"functions/state_vector_functions/#Aerosol-Height","page":"State Vector Functions","title":"Aerosol Height","text":"","category":"section"},{"location":"functions/state_vector_functions/#Aerosol-Optical-Depth","page":"State Vector Functions","title":"Aerosol Optical Depth","text":"","category":"section"},{"location":"functions/state_vector_functions/#Aerosol-Width","page":"State Vector Functions","title":"Aerosol Width","text":"","category":"section"},{"location":"functions/state_vector_functions/#BRDF-Kernel-Polynomial","page":"State Vector Functions","title":"BRDF Kernel Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#Dispersion-Polynomial","page":"State Vector Functions","title":"Dispersion Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#Gas-VMR-Profile","page":"State Vector Functions","title":"Gas VMR Profile","text":"","category":"section"},{"location":"functions/state_vector_functions/#Gas-Level-Scaling-Factor","page":"State Vector Functions","title":"Gas Level Scaling Factor","text":"","category":"section"},{"location":"functions/state_vector_functions/#ILS-Stretch-Polynomial","page":"State Vector Functions","title":"ILS Stretch Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#SIF-Radiance","page":"State Vector Functions","title":"SIF Radiance","text":"","category":"section"},{"location":"functions/state_vector_functions/#Solar-Scaler-Polynomial","page":"State Vector Functions","title":"Solar Scaler Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#Surface-Albedo-Polynomial","page":"State Vector Functions","title":"Surface Albedo Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#Surface-Pressure","page":"State Vector Functions","title":"Surface Pressure","text":"","category":"section"},{"location":"functions/state_vector_functions/#Temperature-Offset","page":"State Vector Functions","title":"Temperature Offset","text":"","category":"section"},{"location":"functions/state_vector_functions/#Zero-Level-Offset-Polynomial","page":"State Vector Functions","title":"Zero Level Offset Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{AerosolHeightSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::AerosolHeightSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to AerosolHeightSVE types should be calculate before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{AerosolHeightSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::AerosolHeightSVE) -> String\n\n\nReturns the name of this aerosol width state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.is_aerosol_SVE-Tuple{AerosolHeightSVE}","page":"State Vector Functions","title":"RetrievalToolbox.is_aerosol_SVE","text":"is_aerosol_SVE(sve::AerosolHeightSVE) -> Bool\n\n\nReturns whether this SVE (sve) is an aerosol-related SVE. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{AerosolOpticalDepthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::AerosolOpticalDepthSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to AerosolOpticalDepthSVE types should be calculate before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{AerosolOpticalDepthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this aerosol OD state vector element as a string.\n\nget_name(sve)\n\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.is_aerosol_SVE-Tuple{AerosolOpticalDepthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.is_aerosol_SVE","text":"is_aerosol_SVE(sve::AerosolOpticalDepthSVE) -> Bool\n\n\nReturns whether this SVE (sve) is an aerosol-related SVE. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{AerosolWidthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(sve::AerosolWidthSVE) -> Bool\n\n\nReturns whether the Jacobian related to AerosolWidthSVE types should be calculate before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{AerosolWidthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::AerosolWidthSVE) -> String\n\n\nReturns the name of this aerosol width state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.is_aerosol_SVE-Tuple{AerosolWidthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.is_aerosol_SVE","text":"is_aerosol_SVE(sve::AerosolWidthSVE) -> Bool\n\n\nReturns whether this SVE (sve) is an aerosol-related SVE. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{BRDFPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::BRDFPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to BRDFPolynomialSVE types should be calculate before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{BRDFPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::BRDFPolynomialSVE) -> String\n\n\nReturns the name of this surface albedo state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{DispersionPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::DispersionPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to DispersionPolynomialSVE types should be calculate before convolution happens. Returns false.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{DispersionPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::DispersionPolynomialSVE) -> String\n\n\nReturns the name of this dispersion state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{GasVMRProfileSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::GasVMRProfileSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to GasVMRProfileSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{GasVMRProfileSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::GasVMRProfileSVE) -> String\n\n\nReturns the name of this dispersion state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.idx_for_profile_sve-Tuple{GasAbsorber, AbstractStateVector}","page":"State Vector Functions","title":"RetrievalToolbox.idx_for_profile_sve","text":"idx_for_profile_sve(\n    gas::GasAbsorber,\n    sv::AbstractStateVector\n) -> Vector{Integer}\n\n\nReturns the positional indices of state vector elements that are a GasVMRProfileSVE and belong to a GasAbsorber gas. This allows easy retrieval of the VMR profile SVEs for some gas\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{GasLevelScalingFactorSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::GasLevelScalingFactorSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to GasLevelScalingFactorSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{GasLevelScalingFactorSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::GasLevelScalingFactorSVE) -> String\n\n\nReturns the name of this dispersion state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{ILSStretchPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::ILSStretchPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to ILSStretchPolynomialSVE types should be calculated before convolution happens. Returns false.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{ILSStretchPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::ILSStretchPolynomialSVE) -> String\n\n\nReturns the name of this ILS stretch state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{SIFRadianceSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(sve::SIFRadianceSVE) -> Bool\n\n\nReturns whether the Jacobian related to SIFRadianceSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{SIFRadianceSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this temperature offset state vector element as a string.\n\nget_name(sve::SIFRadianceSVE) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{SolarScalerPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::SolarScalerPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to SolarScalerPolynomialSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{SolarScalerPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::SolarScalerPolynomialSVE) -> String\n\n\nReturns the name of this solar scaler polynomial state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{SurfaceAlbedoPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::SurfaceAlbedoPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to SurfaceAlbedoPolynomialSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{SurfaceAlbedoPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::SurfaceAlbedoPolynomialSVE) -> String\n\n\nReturns the name of this surface albedo state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{SurfacePressureSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::SurfacePressureSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to SurfacePressureSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{SurfacePressureSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this surface pressure vector element as a string.\n\nget_name(sve::SurfacePressureSVE) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{TemperatureOffsetSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::TemperatureOffsetSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to TemperatureOffsetSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{TemperatureOffsetSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this temperature offset state vector element as a string.\n\nget_name(sve::TemperatureOffsetSVE) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian!-Tuple{AbstractRTBuffer, ZeroLevelOffsetPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian!","text":"calculate_jacobian!(\n    rt_buf::AbstractRTBuffer,\n    sve::ZeroLevelOffsetPolynomialSVE\n) -> Any\n\n\nCalculates the Jacobian for a ZeroLevelOffsetPolynomialSVE\n\nDetails\n\nThe ZLO radiance offset at wavelength of spectral sample s (λ_s) is generally calculated as (and analogously for wavenumbers, ν_s)\n\nsum_i=0^O-1 c_i cdot (λ_s - λ_textref)^i\n\nwhere i runs from 0 up to O - 1, where O is the order of the polynomial. See also apply_radiance_correction! for this SVE type.\n\nThe partial derivative of the radiance I with respect to the polynomial coefficient c_i is then\n\nIc_i = (λ_s - λ_textref)^i\n\nThe reference spectral point (λ_textref or ν_textref) is given by the spectral window object that is attached to the sve as sve.swin.ww_reference. Unit differences between the rt_buf RT buffer and the unit of this sve are explicitly taken into account, so this sve may have any compatible radiance units as long as the converstion to the rt_buf.radiance_unit is valid.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{ZeroLevelOffsetPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::ZeroLevelOffsetPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to ZeroLevelOffsetPolynomialSVE types should be calculated before convolution happens. Returns false since the partial derivative calculation does not need the resulting radiance itself.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_zlo!-Tuple{AbstractVector, Any, ZeroLevelOffsetPolynomialSVE, AbstractDispersion, AbstractVector}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_zlo!","text":"calculate_zlo!(\n    output::AbstractVector,\n    radiance_unit,\n    sve::ZeroLevelOffsetPolynomialSVE,\n    dispersion::AbstractDispersion,\n    indices::AbstractVector\n)\n\n\nCalculates the per-sample zero-level offset as given by the state vector element sve and indexed by the dispersion dispersion. This function is called by apply_radiance_correction! and likely does not need to be done by the user.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{ZeroLevelOffsetPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this ZeroLevelOffsetSVE state vector element as a string.\n\nget_name(sve::ZeroLevelOffsetPolynomialSVE) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"types/atmosphere_types/#Atmosphere-types","page":"Atmosphere Types","title":"Atmosphere types","text":"An EarthAtmosphere object, as the name suggests, characterizes an atmospheric state on Earth with a number of profiles and other quantities to the extent needed by most models to generate radiances.\n\nConvenience functions exist which make the creation of EarthAtmosphere objects easier, such as create_empty_EarthAtmosphere or create_example_atmosphere.\n\nThe concept of an atmospheric state supported by RetrievalToolbox is one that includes two categories of profiles. One type of profile is associated with the retrieval grid, a one-dimensional vertical pressure profile (pressure_levels) that dictates e.g. optical property calculations and also determines the pressures at which the gas profile values are defined. The second  type are the meteorological profiles, reserved for specific humidity, temperature, altitude and gravity. These are laid out on another pressure grid (met_pressure_levels) which can be a completely different one compared to the retrieval grid.\n\nEach profile has its own physical unit with denoted by _unit, so e.g. the altitude levels are stored in .altitude_levels, and the corresponding unit field is .altitude_unit. The type definition restricts the possible units to those that make sense physically, so users can use u\"km\" or u\"m\" as their physical units for the altitude profile, but not e.g. u\"Pa\", as that is not a valid length-type unit.\n\nWhen users write a retrieval algorithm that performs retrievals on many scenes, it is generally advised to not create new atmosphere objects as that tends to fill up memory quite fast. Instead, use the ingest! function to copy values into the atmosphere object, over-writing existing values. As with most objects in RetrievalToolbox, users must be cautious as it is always possible to change values inside the object.","category":"section"},{"location":"types/atmosphere_types/#RetrievalToolbox.EarthAtmosphere","page":"Atmosphere Types","title":"RetrievalToolbox.EarthAtmosphere","text":"atm_elements::Vector{<:AbstractAtmosphereElement}: Vector of atmosphere elements present in this atmosphere\nN_level::Int64: Number of retrieval levels in this atmosphere\nN_layer::Int64: Number of retrieval layers in this atmosphere\npressure_levels::Vector{T} where T<:AbstractFloat: Pressure level locations\npressure_layers::Vector{T} where T<:AbstractFloat: Mid-layer pressure locations\npressure_unit::Unitful.Units{U, 𝐌 𝐋^-1 𝐓^-2} where U: Pressure unit\nN_met_level::Int64: Number of meteorological levels in this atmosphere\nN_met_layer::Int64: Number of meteorological layers in this atmosphere\nmet_pressure_levels::Vector{T} where T<:AbstractFloat: Meteorological pressure level locations\nmet_pressure_layers::Vector{T} where T<:AbstractFloat: Mid-layer pressure locations for meteorology\nmet_pressure_unit::Unitful.Units{U, 𝐌 𝐋^-1 𝐓^-2} where U: Pressure units for meteorology\ntemperature_levels::Vector{T} where T<:AbstractFloat: Temperatures at pressure levels\ntemperature_layers::Vector{T} where T<:AbstractFloat: Temperatures at mid-layer pressures\ntemperature_unit::Unitful.Units{U, 𝚯, nothing} where U: Temperature unit\nspecific_humidity_levels::Vector{T} where T<:AbstractFloat: Specific humidity at pressure levels\nspecific_humidity_layers::Vector{T} where T<:AbstractFloat: Specific humidity at mid-layer pressures\nspecific_humidity_unit::Unitful.Units{U, NoDims} where U: Specific humidity unit\naltitude_levels::Vector{T} where T<:AbstractFloat: Altitude at pressure levels\naltitude_layers::Vector{T} where T<:AbstractFloat: Altitude at mid-layer pressures\naltitude_unit::Unitful.Units{U, 𝐋} where U: Altitude units\ngravity_levels::Vector{T} where T<:AbstractFloat: Gravity at pressure levels\ngravity_layers::Vector{T} where T<:AbstractFloat: Gravity at mid-layer pressures\ngravity_unit::Unitful.Units{U, 𝐋 𝐓^-2} where U: Gravity unit\n\n\n\n\n\n","category":"type"},{"location":"design/design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/design/#Namespace","page":"Design","title":"Namespace","text":"The RetrievalToolbox module exports many functions, types and variables - some of those might share names with functions from other modules or your own user code. While not strictly necessary, we generally recommend to load the module and then declare an alias to then call the module functions through it.\n\nusing RetrievalToolbox\nconst RE = RetrievalToolbox\n\nRE.some_function()\n\n# this, however, works too\nsome_function()","category":"section"},{"location":"design/design/#Reliance-on-Julia-types","page":"Design","title":"Reliance on Julia types","text":"One of Julia's most prominent features is the flexibility that comes with its rich type system. While not object-oriented in the sense that C++ is, objects, their relationship to functions, and how they act on specific objects is a major design component of Julia and thus RetrievalToolbox.\n\nRetrievalToolbox defines a number of abstract types and then lots of composite types, which are akin to struct types in C. They usually sit below abstract types in the type hierarchy and represent some granular concept that is useful for trace gas retrievals.\n\nFor example, the GaussAerosol type belongs to the AbstractAerosolType which itself belongs to AbstractAtmosphereElement, and describes some aerosol whose vertical distribution in the model atmosphere is described by a Gaussian. The full type hierarchy here is GaussAerosol ⊂ AbstractAerosolType ⊂ AbstractAtmosphereElement. When users create a model atmosphere, they must add some AbstractAtmosphereElement to the list of atmosphere elements. At that stage, we do not care what specific object that might be, as long as it satisfies the requirement that it has to be a type that is a subtype of AbstractAtmosphereElement.\n\nNow how does Julia's type system and the multiple dispatch paradigm help us here. First, it allows for some convenience. We can use some list of atmospheric elements that we want represented in our model atmosphere: aerosols and Rayleigh scattering. Those two are quite different in practical terms, even though they might act in similar ways on our various calculations. So if we have some list of AbstractAtmosphereElement objects\n\natm_list = [aerosol1, aerosol2, RayleighScattering()]\n\nwe would ideally want to perform some action with each of those elements, such as calculating their contribution to the optical depth profiles of our model atmosphere. Some naïve way of doing that would be to iterate through each element and perform the appropriate action:\n\nfor atm in atm_list\n    if is_an_aerosol(atm)\n        tau = calculate_gauss_aerosol_tau(atm)\n    end\n\n    if is_Rayleigh_scattering(atm)\n        tau = calculate_Rayleigh_tau(atm)\n    end\n\n    # .. do something with tau\nend\n\nThis is easily done with Julia, but makes this top-level iteration not very elegant. One can imagine that if we implement several aerosol distribution types, this loop will grow since we want to call the dedicated function to perform the wanted operation. The preferred way in Julia is making use of multiple dispatch: we decide on a name for a function that shall perform the equivalent task for different types. Let us call this function calculate_tau:\n\nfor atm in atm_list\n    tau = calculate_tau(atm)\n    # .. do something with tau\nend\n\nand as long as there is a function calculate_tau which implements the calculate for the requested type, above code will execute and keep this top-level loop nice and tidy.\n\nWhile the above example allows for some convenience, the strength of multiple dispatch also lies in how users can expand code without having to change code deep within a module they use. For example, let us imagine a new aerosol type that a user wants to integrate in their retrieval application: MyAerosolType. A new list of atmosphere elements would be created, like so\n\nmy_new_aerosol = MyAerosolType()\natm_list = [aerosol1, aerosol2, RayleighScattering(), my_new_aerosol()]\n\nNow in this imagined scenario, the user can now create their own calculate_tau function, which would implement the specific routine that computes the optical depth profiles for their new aerosol type:\n\nfunction calculate_tau(a::MyAerosolType)\n    # Do many calculations here...\n    # ...\nend\n\nWhen done correctly, the new function will be invoked when the loop above runs (for atm in atm_list ...)  since the Julia compiler will now look for a calculate_tau function that can act on an object of type MyAerosolType.\n\nTo summarize: RetrievalToolbox makes extensive use of Julia's type system such that many functions in the module do not act on primitive types (like numbers or strings), but on custom composite types.\n\ninfo: Info\nThe Julia type system allows for flexibility in creating program code that looks the same for a variety of object types. Further, users can more easily extend existing code with their own types without necessarily having to change the underlying routines, but by providing their own user code.","category":"section"},{"location":"design/design/#Buffers-for-performance-and-convenience","page":"Design","title":"Buffers for performance and convenience","text":"Julia is a garbage-collected language (more detailed info here), meaning that users do not have explicit control over how and when objects are de-allocated from memory. When users write functions that allocate (by creating vectors and arrays, for example), the memory is not immediately freed when the function is completed. The garbage collector (GC) is triggered at some point when the memory usage reaches some level. The GC then traces through the objects in memory and removes those that are no longer used.\n\nThe big advantage of GC-based languages is of course that manual memory management is no longer needed, and users do not have to keep track of correct allocation and de-allocation of objects, and memory safety issues are also less common. The major downside is that without manual memory management, users could (un)willingly write code that very inefficiently allocates a lot of memory. When those allocations happen in certain places (loops mostly), memory will fill up quickly and trigger GC sweeps very often. The paradigm within Julia is usually: allocate big arrays and vectors beforehand, and perform calculations on these pre-allocated objects.\n\nEarly versions of RetrievalToolbox did not make use of much pre-allocation, and most calls to functions would create new objects. This has proven to be not a feasible solution. While convenient for top-level scripting, the many allocations needed made it impossible to run faster retrievals where the forward model run was much less than a second (e.g. physics-based SIF retrievals or other non-scattering applications).\n\nThus, we make use of pre-allocated objects, and some of them are collected into objects that we call buffers. Types that belong into this category are found in src/types/buffer_types.jl. Some users might be familiar with LAPACK's WORK arrays to hold temporary results, which have to be managed by the user. Buffers in RetrievalToolbox are conceptually the same.\n\nThe simplest buffer at the moment is the InstrumentBuffer type, which is simply a collection of three vectors that are meant to be used as as temporary vectors for instrument model-related operations such as the application of the instrument spectral response function (RetrievalToolbox.apply_isrf_to_spectrum!) which requires an InstrumentBuffer. In most retrieval applications, users will likely want to process many scenes per invocation of their program. Buffers are intended to be re-used, so they can be created once and then used over and over. Functions in RetrievalToolbox which use buffers ensure that the contents of the buffers are \"cleared out\" (generally set to zero). Users do not have to worry about what values are inside buffers before calling functions that use them.\n\nCurrently, the top-level buffer is the EarthAtmosphereBuffer which itself includes buffers and other objects with pre-allocated elements. For most applications, users will want to create an EarthAtmosphereBuffer to represent a collection of easily accessed objects.\n\nBuffers are represented by their own types, listed here: Buffer Types.","category":"section"},{"location":"design/design/#Order-of-instantiation-in-a-retrieval-algorithm","page":"Design","title":"Order of instantiation in a retrieval algorithm","text":"","category":"section"},{"location":"design/design/#Executing-the-forward-model-will-mutate-some-objects","page":"Design","title":"Executing the forward model will mutate some objects","text":"Kinda bad for e.g. gas scale factors that mean factors of some initial atmospheric state.","category":"section"},{"location":"design/design/#Explicit-and-lengthy-or-simplified-and-short?","page":"Design","title":"Explicit and lengthy or simplified and short?","text":"Explain why some code sections look explicitly verbose and long, and why making it shorter and less verbose is an option - sometimes.","category":"section"},{"location":"design/design/#Wrapper-functions-and-specific-dispatch","page":"Design","title":"Wrapper functions and specific dispatch","text":"","category":"section"},{"location":"design/design/#Considering-quantities-with-physical-units","page":"Design","title":"Considering quantities with physical units","text":"Explain types and dedicated type fields for units. Pay attention to supplying quantities with the right units!","category":"section"},{"location":"design/design/#Wavelengths-and-wavenumbers","page":"Design","title":"Wavelengths and wavenumbers","text":"RetrievalToolbox supports two fundamental spectral unit types: wavelength and wavenumber. Users might want to build an algorithm pipeline that is specific to some instrument, which natively produces spectra in either wavelength or wavenumber units. In order to make the native spectral unit be visible as such, RetrievalToolbox provides dynamic accessors which allow users to reference the spectral unit of objects using their natural wording or symbol.\n\nRather than writing duplicate types and functions, RetrievalToolbox employs magic accessor methods. Any quantity that represents a spectral unit, is typed ww or, for example, ww_unit or ww_reference. The two-letter combination ww is thus reserved in the RetrievalToolbox codebase, and no type fields should contain this combination of letters.\n\nThe ww should be considered a placeholder, which represents either a wavelength- or a wavenumber-related quantity. Any type that contains a field or quantity ww must also contain a field named ww_unit. Other fields are optional.\n\nWhen the RetrievalToolbox module is imported, all types inside the RetrievalToolbox namespace are scanned for type fields that contain the substring ww. For each type that contains such a field, a new accessor function is dynamically created, which allows users to access the spectral type fields with the appropriate symbol. Illustrative examples follow.\n\nCreating a spectral window object from 1.49 µm through 1.55 µm with 10 nm spacing could, for example, look like this (with loaded Unitful):\n\nusing RetrievalToolbox # hide\nconst RE = RetrievalToolbox # hide\nusing Unitful # hide\n\nswin = RE.SpectralWindow(\n    \"test\",\n    1.49, # Lower limit\n    1.55, # Upper limit\n    collect(1.48:0.01:1.56), # Create the grid with spacing\n    Unitful.µm, # Designate microns as unit of choice\n    1.50 # Set some reference wavelength\n    )\n\nAs can be seen in the type definition, the spectral grid can be accessed via swin.ww_grid.\n\nswin.ww_grid;\nshow(swin.ww_grid')\n\nNow the magic accessor allows users to access the same field using the more \"natural\" wavelength term\n\nswin.wavelength_grid;\nshow(swin.wavelength_grid')\n\nor even the Unicode symbol λ:\n\nswin.λ_grid;\nshow(swin.λ_grid')\n\nNote that swin.λ_grid or swin.wavelength_grid do not perform a calculation or conversion. For the spectral window type SpectralWindow, an overloaded getproperty function was dynamically created during startup such that getproperty(SpectralWindow, :λ) returns the ww_grid field, and similarly for wavenumber units.\n\nSince types with some spectral dimension must also have a corresponding unit field, ww_unit, the getproperty function is able to check whether the requested spectral unit is appropriate. Trying to access swin.wavenumber_grid or swin.ν_grid will fail:\n\nswin.wavenumber_grid # or swin.ν_grid\n\nBenchmarks have shown there is no significant performance drawback due to the use of the new getproperty functions.\n\nWhen writing new functions that use objects of any types with a spectral unit, users can interrogate the ww_unit field to control the behavior of calculations. Inside RetrievalToolbox, this is done, for example, for the Doppler shift calculations, which use different expressions depending on whether they are performed in wavelength or wavenumber space.\n\nfunction something_new(swin::RE.SpectralWindow)\n\n    if swin.ww_unit isa Unitful.LengthUnit\n        # Do calculations in wavelength space\n    elseif swin.ww_unit isa Unitful.WavenumberUnit\n        # Do calculations in wavenumber space\n    end\n\nend\n\nWhen users write functions, they should be mindful of when they use .ww_grid compared to .wavelength_grid or .wavenumber_grid. For many calculations, it makes no difference whether the spectral unit is wavelength or wavenumber, and thus writing .ww is legible and reasonable. If some function only makes sense in one spectral unit, but not in the other, then .wavenumber_grid or .wavelength_grid can be used. Note that in this case, an error will be thrown if an object with the wrong spectral unit is passed into this function, and the spectral unit will be accessed via .wavenumber_grid or .wavelength_grid. This might be the desired behavior - calculations should throw an error if invoked in the wrong spectral unit space.\n\nWhen users write top-level retrieval scripts for some specific scenario, it is usually most obvious to write the specific spectral unit, as that does not change and it also becomes clear that only that specific spectral unit is considered. I.e., a retrieval script that launches OCO-2 retrievals should access the spectral unit with .wavelength_grid.","category":"section"},{"location":"design/design/#Build-your-own-algorithm!","page":"Design","title":"Build your own algorithm!","text":"","category":"section"},{"location":"design/design/#Custom-forward-model","page":"Design","title":"Custom forward model","text":"","category":"section"},{"location":"design/design/#Lack-of-an-instrument-type","page":"Design","title":"Lack of an instrument type","text":"","category":"section"},{"location":"design/design/#Custom-ingestion-of-needed-inputs","page":"Design","title":"Custom ingestion of needed inputs","text":"","category":"section"},{"location":"types/buffer_types/#buffer_types","page":"Buffer Types","title":"Buffer types","text":"Below are the currently supported buffer types which represent collections of pre-allocated objects that can be used over and over in situations where users want to e.g. perform many retrievals. The following buffers can be created once and then used repeatedly for different scenes. The slower the retrieval process itself is, the lower is the overall performance gain from re-using buffers, however. For very fast retrievals with completion times less then a few seconds, it is highly recommended to re-use the buffers.","category":"section"},{"location":"types/buffer_types/#How-to-construct-an-EarthAtmosphereBuffer","page":"Buffer Types","title":"How to construct an EarthAtmosphereBuffer","text":"The EarthAtmosphereBuffer type requires itself several other objects based on RetrievalToolbox types. Most importantly, a number of functions that RetrievalToolbox provides implicitly assume that all those objects are correctly instantiated and all relevant relationships hold across the type hierarchy. While it is possible to create an EarthAtmosphereBuffer object manually, it is highly recommended to use the convenience function that is provided with RetrievalToolbox. In cases where this convenience function does not produce the right configuration due to specific user needs, the best course of action is to copy the function code (src/buffers.jl) into a new module and make appropriate changes to capture those cases. See also: How to develop or extend RetrievalToolbox.\n\nBefore an EarthAtmosphereBuffer can be successfully created, users must first have various other objects prepared beforehand.\n\nsv: some AbstractRetrievalStateVector objects, which can be empty, i.e. write sv = RetrievalStateVector([]). Note the following, however.\nspectral_windows: a list of AbstractSpectralWindow objects\nsurface_types: a list of tuples, indicating the type of surface to be used, along with parameters (see below: surface types)\natmospheric_elements: a list of AbstractAtmosphereElement objects\nsolar_models: a dictionary which maps AbstractSpectralWindow objects to AbstractSolarModel ones so that RetrievalToolbox knows which solar model is to be used for which spectral window. Several (or all) spectral windows may point to the same solar model.\nRT_models: a list of symbols to indicate which type of radiative transfer model is to be used for each spectral window. The order must be the same as given in the spectral_windows list.\nRadType: the type of radiance to be used, either ScalarRadiance or VectorRadiance\nrt_buf: an AbstractRTBuffer\ninst_buf: an InstrumentBuffer\nN_level: the number of retrieval levels of the EarthAtmosphere\nN_met_level: the number of meteorology profile levels of the EarthAtmosphere\nT: the number type to be used for arrays (Float64 is recommended)\n\nwarning: Warning\nIn most cases, users will want to make sure that sv, the state vector supplied to this convenience function, is the same state vector that is used to map the keys of the jacobian dictionary of the RT buffer rt_buf. There is currently no check in place to verify this.","category":"section"},{"location":"types/buffer_types/#surface_types_buffer","page":"Buffer Types","title":"Surface types","text":"Both RT_models and surface_types arguments must be ordered according to the spectral_windows argument (list of spectral windows). For example, let there be three spectral windows we want to use, swin_A, swin_B, swin_C such that spectral_windows = [swin_A, swin_B, swin_C]. Users have the choice to perform RT calculations with different models for each spectral window. So if the first two windows should be run with a Beer-Lambert-type RT and the last one use the XRTM library, one would write RT_models = [:BeerLambert, :BeerLambert, :XRTM]. Similarly, we proceed to assign surface types. At the moment only Lambertian-type surface are supported with the BeerLambertRTMethod, but for a MonochromaticRTMethod that employs the XRTM solver, we can make use of the RPV BRDF kernel:\n\nsurface_types = [\n    (:Lambertian, 2),\n    (:Lambertian, 2),\n    (:RPV, 2, 0.05, -0.1, 0.75),\n    ]\n\nFor the Lambertian surface, there is only one needed parameter, which is the order of the polynomial to capture the spectral dependence. For the RPV BRDF kernel, three additional parameters need to be part of the tuple: the hotspot, asymmetry and anisotropy parameters (see also RPVPolynomialKernel). The important part here is that the surface are created and assigned, in order such that swin_A and swin_B both get their own Lambertian surfaces, and the RPV BRDF kernel surface will be attached to swin_C.","category":"section"},{"location":"types/buffer_types/#How-to-use-an-EarthAtmosphereBuffer","page":"Buffer Types","title":"How to use an EarthAtmosphereBuffer","text":"Once created, users must fill the various arrays and vectors of an EarthAtmosphereBuffer with meaningful values such that the other various routines can produce sensible values. An EarthAtmosphereBuffer only contains one EarthScene, which itself contains only one EarthAtmosphere; hence if buf is the name of the EarthAtmosphereBuffer, one would access the atmosphere object via buf.scene.atmosphere.\n\nFor example, calculating the gravity and altitude profiles for an existing atmosphere requires the atmosphere object to have valid meteorological pressure, temperature and specific humidity profiles along with a valid location and altitude. Assuming buf was created successfully beforehand, one would use below lines to manipulate the EarthAtmosphere inside the buffer.\n\n# Create a location: lon, lat, altitude, altitude unit\nbuf.scene.location = RE.EarthLocation(0.0, 45.0, 100.0, u\"m\")\n\n# Set MET profiles\nbuf.scene.atmosphere.met_pressure_levels[:] .= ... # copy met P\nbuf.scene.atmosphere.temperature_levels[:] .= ... # copy met T\nbuf.scene.atmosphere.specific_humidity_levels[:] .= ... # copy met q\n\n# Calculate g and z (in-place operation), this will update\n# buf.scene.atmosphere.altitude_levels and buf.scne.atmosphere.gravity_levels\nRE.calculate_altitude_and_gravity!(buf.scene)\n\nIn another example, we use the instrument buffer attached to the EarthAtmosphereBuffer to perform an instrument model calculation - applying some instrument spectral response function:\n\nswin = buf.spectral_window[2] # take the second spectral window from the list\n\nRE.apply_isrf_to_spectrum!(\n    buf.inst_buf, # the instrument buffer created beforehand\n    ISRF, # my ISRF\n    buf.rt_buf.dispersion[swin], # grab the corresponding dispersion\n    some_high_resolution_spectrum, # a result from a forward model run perhaps\n    swin # the spectral window we picked\n)\n\nNote that in the above example, we make sure that the right objects are passed into the function.\n\nSee this tutorial for relevant learning materials and more details.","category":"section"},{"location":"types/buffer_types/#Types","page":"Buffer Types","title":"Types","text":"","category":"section"},{"location":"types/buffer_types/#RetrievalToolbox.EarthAtmosphereBuffer-Tuple{AbstractStateVector, Any, Vector{Tuple}, Any, Dict{<:AbstractSpectralWindow, <:AbstractSolarModel}, Vector{Symbol}, Type{<:Union{ScalarRadiance, VectorRadiance}}, AbstractRTBuffer, Any, Integer, Integer, Type{<:AbstractFloat}}","page":"Buffer Types","title":"RetrievalToolbox.EarthAtmosphereBuffer","text":"EarthAtmosphereBuffer(\n    sv::AbstractStateVector,\n    spectral_windows,\n    surface_types::Vector{<:Tuple},\n    atmospheric_elements,\n    solar_models::Dict{<:AbstractSpectralWindow, <:AbstractSolarModel},\n    RT_models::Vector{Symbol},\n    RadType::Type{<:Union{ScalarRadiance, VectorRadiance}},\n    rt_buf::AbstractRTBuffer,\n    inst_buf,\n    N_level::Integer,\n    N_met_level::Integer,\n    T::Type{<:AbstractFloat}\n) -> EarthAtmosphereBuffer\n\n\nHelper function to populate an EarthAtmosphereBuffer, which also includes an EarthAtmosphere and the corresponding OpticalProperties with correctly sized arrays. Ensure that the state vector sv is the same that was used to generate the RT buffer rt_buf!\n\nDetails\n\nPlease see the on-line documentation (via the Github page) for a more detailed explanation on the use of this function.\n\n\n\n\n\n","category":"method"},{"location":"types/buffer_types/#RetrievalToolbox.EarthAtmosphereBuffer","page":"Buffer Types","title":"RetrievalToolbox.EarthAtmosphereBuffer","text":"spectral_window::Vector{<:AbstractSpectralWindow}: A vector of type AbstractSpectralWindow to hold all spectral windows used in this buffer\nscene::EarthScene: An EarthScene\noptical_properties::Dict{<:AbstractSpectralWindow, EarthAtmosphereOpticalProperties}: A Dict to hold the optical properties attached to an AbstractSpectralWindow\nrt::Dict{<:AbstractSpectralWindow, <:AbstractRTMethod}: A Dict to hold the RT buffer attached to an AbstractSpectralWindow\nrt_buf::AbstractRTBuffer: An RT buffer object to hold retrieval-wide radiances and Jacobians\ninst_buf::InstrumentBuffer: A convolution buffer object to help with the ISRF application\n\nA buffer for use in EarthAtmosphere type simulations and/or retrievals, containing other buffers as well as the EarthScene to describe the location and the atmospheric state.\n\nDetails\n\nThis buffer is needed to represent a full single-scene modeled measurement at one time and location. It is highly recommended to not instantiate this buffer object manually, but to use the corresponding EarthAtmosphereBuffer function that helps produce this. Manually creating this object carries the risk of some of the dictionaries having incorrect keys.\n\n\n\n\n\n","category":"type"},{"location":"types/buffer_types/#RetrievalToolbox.InstrumentBuffer","page":"Buffer Types","title":"RetrievalToolbox.InstrumentBuffer","text":"tmp1::Vector{T} where T<:AbstractFloat\ntmp2::Vector{T} where T<:AbstractFloat\nlow_res_output::Vector{T} where T<:AbstractFloat\n\nAn instrument buffer type to hold pre-allocated arrays for use in instrument-related functions such as the application of ISRFs.\n\n\n\n\n\n","category":"type"},{"location":"types/buffer_types/#RetrievalToolbox.ScalarRTBuffer","page":"Buffer Types","title":"RetrievalToolbox.ScalarRTBuffer","text":"dispersion::Dict{<:AbstractSpectralWindow, <:AbstractDispersion}: Dict to map spectral windows to dispersion objects\nradiance::ScalarRadiance{T1, Vector{T1}} where T1<:AbstractFloat: Scalar radiance vector representing the at-instrument radiance\njacobians::Union{Nothing, Dict{<:AbstractStateVectorElement, ScalarRadiance{T1, Vector{T1}}}} where T1<:AbstractFloat: At-instrument level jacobians, either a Dict that maps state vector elements to a     ScalarRadiance, or nothing.\nindices::Dict{<:AbstractSpectralWindow, Vector{T2}} where T2<:Integer: Dict to map spectral windows to positions in radiance.\nradiance_unit::Union{Number, Unitful.Units}: Radiance unit of radiance.\n\nAn RT buffer type for scalar radiances, representing, for example, an instrument that is capable of detecting total intensity only, which is what most remote sensing instruments do. Note that this is different from the instrument having polarization sensitivity. The role of this buffer is to provide pre-allocated vectors to hold the various radiance and Jacobian values after potential instrument models are applied.\n\nNotes\n\nThe radiance_unit field is a Union of some arbitrary unit and a generic number type. This is to allow e.g. DOAS-type retrievals, where the measured radiance is considered as a ratio of some sort, and thus does not have a physical unit. Users are meant to then supply u\"1\" as the radiance_unit. Warning: if users supply any number, such as radiance_unit=4.5, expect that to act as a scaling factor by which state vector elements will be scaled, as to bring a radiance-valued state vector element (for example, ZeroLevelOffsetPolynomialSVE) to the same unit as the RT Buffer. It is advised to not do so.\n\nJacobians\n\nAt-instrument Jacobians are stored inside a Dict that map every state vector element to a ScalarRadiance object. Users can also instantiate a ScalarRTBuffer object without Jacobians, by simply passing nothing.\n\nIndices\n\nIndices allow users to connect spectral windows and positions inside the radiance vector to ensure the correct relationship between them. For example, if swin is the spectral window, and the ScalarRTBuffer is rt_buf, the at-detector radiances should be stored at rt_buf.radiance.I[rt_buf.indices[swin]]. Note that radiances are not automatically copied there, but must be copied by users themselves.\n\n\n\n\n\n","category":"type"},{"location":"types/buffer_types/#RetrievalToolbox.VectorRTBuffer","page":"Buffer Types","title":"RetrievalToolbox.VectorRTBuffer","text":"dispersion::Dict{<:AbstractSpectralWindow, <:AbstractDispersion}\nradiance::VectorRadiance{T1, Matrix{T1}} where T1<:AbstractFloat\njacobians::Union{Nothing, Dict{<:AbstractStateVectorElement, VectorRadiance{T1, Matrix{T1}}}} where T1<:AbstractFloat\nindices::Dict{<:AbstractSpectralWindow, Vector{T2}} where T2<:Integer\nradiance_unit::Union{Number, Unitful.Units}\n\nAn RT buffer type for vector radiances, representing an instrument that is capable of detecting the polarization state of light. Chances are this is not what you need, since almost all known remote sensing devices measure intensity only - even if they have some polarization sensitivity.\n\n\n\n\n\n","category":"type"},{"location":"pitfalls/pitfalls/#Known-pitfalls-and-issues","page":"Pitfalls","title":"Known pitfalls & issues","text":"This section of the documentation deals with known pitfalls regarding the usage of the toolkit, as well as more structural issues. Due to the highly modular philosophy of this software, many critical portions of an algorithm implementation are up to the user and, by design, not part of the toolkit itself. Thus, it is easily possible to break some of the intended program flow.","category":"section"},{"location":"pitfalls/pitfalls/#Azimuthal-angles-and-convention-for-use-with-XRTM","page":"Pitfalls","title":"Azimuthal angles and convention for use with XRTM","text":"","category":"section"},{"location":"pitfalls/pitfalls/#Mutability-of-many-RetrievalToolbox-objects","page":"Pitfalls","title":"Mutability of many RetrievalToolbox objects","text":"","category":"section"},{"location":"pitfalls/pitfalls/#Angles-and-trigonometric-functions-with-Unitful.jl","page":"Pitfalls","title":"Angles and trigonometric functions with Unitful.jl","text":"In Julia, calling trigonometric functions is straightforward, with angles being naturally considered to be in units of radiants:\n\nsin(pi/2)\n\nThere are also trigonometric functions that ingest angles in degrees, which are conveniently named the same but append a d at the end, e.g. sin becomes sind, or cos becomes cosd. The behavior is as expected\n\nsind(90.0)\n\nWhen using the Unitful.jl package, one can attach appropriate units to angle values. The library also provides an implementation of the common trigonometric functions such that the appropriate unit conversions take place internally:\n\nusing Unitful # hide\n\nx = 90u\"°\"\nsin(x)\ncos(x)\n\nSimilarly, the cosd and sind functions as provided by Unitful.jl accept degree-valued quantities that provide the correct result. In the case of some degree-valued quantity, x, the result happens to the same:\n\nusing Unitful # hide\n\nx = 55u\"°\"\nsin(x)\nsind(x)\n\n\nLooking closer into what functions are called, we observe that sin and sind provide the interface to the correct function when the argument is a degree-valued quantity. However if the argument is radians-valued, sind will not perform the appropriate conversion!\n\nusing Unitful # hide\n\nx = 45u\"°\"\ny = (pi/4)u\"rad\"\n\ncode_lowered(sin, tuple(typeof(x)))\ncode_lowered(sind, tuple(typeof(x)))\ncode_lowered(sin, tuple(typeof(y)))\ncode_lowered(sind, tuple(typeof(y)))\n\n\nThe code block above shows that sind, when called with a radians-valued quantity will simply perform a deg2rad conversion and use the sin function on the argument. More importantly, no error will be thrown when such a computation is attempted!\n\nusing Unitful # hide\n\ny = (pi/4)u\"rad\"\nz = y |> u\"°\"\n\n# This is not what we want!\nsind(y)\n# This is!\nsind(z)\n\n\nwarning: Warning\nTrigonometric functions meant for degree-valued arguments, such as sind or cosd do not perform automatic unit conversions, even if the argument is a Unitful quantity! Calculating cosd((pi/2)u\"rad\") will yield an unexpected answer!\n\ntip: Tip\nIt is best-practice to clearly document which units certain angle variables must have, and then use the appropriate trigonometric functions! Always use e.g. cosd when degree-valued angles are expected, but use e.g. cos if a Unitful angle quantity is expected.\n\nFurther, users should be aware of implicit conversions when assigning angle-valued quantities to object fields. This is a particular danger with buffers, as those are instantiated and then modified in-place at some later point. The example below illustrates the issue.\n\nAssume some mutable, user-defined type t that accepts some float as its only field. We then instantiate a new variable v with some arbitrary value.\n\nusing Unitful # hide\nmutable struct t{T <: AbstractFloat}\n    a::T\nend\n\nv = t(123.456)\n\nAt some later point, we would like to change v.a. For the sake of this example, assume we want to give it the value of 15 degrees. Following code executes without raising an error.\n\n\nv.a = 15.0u\"°\"\n\nYet, when we inspect the value v.a itself, we see that an implicit conversion has taken place which turned the 15° into equivalent radians. The conversion happened since angular units are dimensionless, or have dimension [1], so can always be turned into a Unitful.NoUnits quantity which then can be cast into a \"regular\" Julia number. Some function which might perform a calculation on some object of this type, therefore should not use the degree-versions of trigonometric functions.\n\nv.a\ndeg2rad(15.0)\n\nwarning: Warning\nUnitful angle-valued quantities are prone to implicit conversions to radians!","category":"section"},{"location":"julia/dicts/#working_with_dicts","page":"Dictionaries","title":"Working with Dictionaries","text":"","category":"section"},{"location":"julia/dicts/#Introduction","page":"Dictionaries","title":"Introduction","text":"Dictionaries in Julia are very similar to dictionaries in other scripting languages, and most details can be found in the official documentation here. The basic idea is the same as in Python, for example: a dictionary is a collection of items that are accessed by keys. In general, almost anything that can be assigned as a variable in Julia is a valid item, and every hash-able object can act as a key.\n\nOne would write in Python\n\n# Python example\nd = {1: \"one\", 2: \"two\"}\n\nand similarly in Julia\n\n# Julia example\nd = Dict(1 => \"one\", 2 => \"two\")\n\nIn both Python and Julia, the values can be accessed in various ways, such as directly typing the key:\n\n# Python\nd[1]\n# should result in output of \"one\"\n\nand here the Julia output:\n\n# Julia\nd[1]\n\nThere are differences between Python's and Julia's dictionaries however, and two of those are particularly important for RetrievalToolbox. First, many more of Julia's various objects are hash-able, and can therefore be used as keys in dictionaries. For example, we can create a dictionary whose keys are arrays:\n\nd = Dict([1,2,3] => \"first three\", [4,5] => \"four and five\")\n\nThe example above is not possible in (pure) Python as lists or numpy arrays are not hash-able by default. The second important difference relates to the specific data type of dictionaries. In Julia, they are not simply \"dictionaries\", but can be specific dictionary types that lay out the specific types of both keys and items. In the example above, the dictionary type is actually printed along with the contents: this dictionary d maps a vector of 64-bit integers (Vector{Int64}) to strings (String).\n\nOnce created, it is possible to add new items to the collection as long as they match the dictionary type. Thus, we can add another item:\n\nd[[100]] = \"only one hundred\"\nd\n\nHowever, the following fails, since the key is not a list of 64-bit integers:\n\nd[101] = \"one hundred and one\"\n\nJulia attempts by default to automatically convert 101 into a Vector{Int64} object, but no such conversion exists, and therefore the call above fails.\n\nIn order to allow for key/item pairs of different types to be stored in one dictionary, one must initialize the dictionary accordingly. The most general form is a dictionary of type Dict{Any,Any} which can map any key to any item:\n\nd = Dict{Any,Any}()\nd[\"something\"] = [1,2,3]\nd['a'] = 1:3\nd[123.456] = Float32\nd\n\nAs can be seen in the code above, we can add key/item pairs of String/Vector{Int64}, Char/UnitRange{Int64} and Float64/DataType into the dictionary, and it will be accepted since d can use Any for both keys and items.\n\nUsage of Any in dictionaries can be convenient, however is generally discouraged in cases where performance matters. In RetrievalToolbox, as we will see below, dictionaries are used for bookkeeping mostly, and there is no performance-critical component directly attached to them. There are a few cases in RetrievalToolbox, where Any is used as either the key or item type.","category":"section"},{"location":"julia/dicts/#Usage-in-RetrievalToolbox","page":"Dictionaries","title":"Usage in RetrievalToolbox","text":"Dictionaries in RetrievalToolbox are used to perform bookkeeping in order to connect different objects together that are related without having some explicit dependency. A very instructive example are objects of type EarthAtmosphereOpticalProperties. Inside those objects we find fields such as aerosol_tau or gas_tau. Those fields are intended to contain the spectrally dependent per-layer optical depths due to aerosols or gases present in the model atmosphere. The optical depth information is stored as array to allow for high-performance computations.\n\nBookkeeping is crucial; we want to minimize possible assignment errors, meaning the confusion of which gas and which array belong together. Traditionally, the bookkeeping would be done via some form of index which would be carried throughout the program to (for example) signify that index 1 represents the oxygen gas, and index 2 is water vapor.\n\nDictionaries allow us to make this bookkeeping more intuitive and more elegantly. the gas_tau field, for example, is a dictionary of type Dict{GasAbsorber{T}, Array{T, 2}}. In this dictionary we directly map a GasObserver object to the matching array. There is no need to carry an additional bookkeeping token which links the correct gas absorber to the correct array.\n\nAnother example is how radiative transfer (RT) objects are managed inside the EarthAtmosphereBuffer. Since it is possible to arrange for several spectral windows to be part of a buffer, the RT methods are indexed in a dictionary of type Dict{<:AbstractSpectralWindow, <:AbstractRTMethod}. For some EarthAtmosphereBuffer buf, and a spectral window swin, we can write\n\nrt = buf.rt[swin]\n\nwhich would return the AbstractRTMethod object that is logically linked to our spectral window. Note again here the distinction. The AbstractRTMethod object itself does not have an explicit dependence on the spectral window, even though its field optical_properties does. Hence, dictionaries like this are usually employed when the direct dependence is not established within object properties themselves, but needs to be tracked overall.\n\nSo internally, this type of referencing can reduce potential programming errors. There is also a benefit on the user side. If users want to inspect some underlying quantity, like the layer-resolved optical depths due to gas absorption, the also do not have to worry about some arbitrary index that links a gas to this quantity. One could just inquire via the gas objects themselves.\n\n# let `swin` be the spectral window of interest, and `buf` be a buffer object\nrt = buf.rt[swin] # Get the RT object from `swin`\ngas_o2 = RE.get_gas_from_name(buf.scene.atmosphere, \"O2\") # Get the gas object\n# We can now obtain the optical depth array for the gas `gas_o2`\ngas_tau_o2 = rt.optical_properties.gas_tau[gas_o2]\n\nIn above code example, there was no need to use any arbitrary index to access the objects of interest, the objects themselves reference each other where appropriate: starting from some spectral window swin, we take the RT object rt via the dictionary buf.rt. Since we also have our gas observer gas_o2, we can directly obtain the gas optical depth array through the rt.optical_properties dictionary by use gas_o2 as the key.\n\nNote that adding allocated objects to an existing dictionary, or even creating a dictionary with already allocated objects, does not (in general) allocate new memory! Therefore, there is no additional memory footprint due to objects appearing in one or more dictionaries.\n\nLook at the memory footprint below. The first call allocates a new array in memory and reserves several MiB of memory in the process. The second call only establishes the dictionary via referencing and does not need to allocate the existing array anew.\n\n_blank = Dict(1 => rand(2,2)) # hide\n@time a = rand(500, 5_000);\n@time d = Dict(1 => a);\n\ntip: Tip\nCreating a dictionary in Julia with existing objects generally does not allocate new memory!","category":"section"},{"location":"concepts/phasefunction/#Scattering-Phase-Function-and-its-Expansion","page":"Scattering Phasefunction","title":"Scattering Phase Function and its Expansion","text":"","category":"section"},{"location":"types/dispersion_types/#dispersion_types","page":"Dispersion Types","title":"Dispersion Types","text":"","category":"section"},{"location":"types/dispersion_types/#RetrievalToolbox.SimplePolynomialDispersion","page":"Dispersion Types","title":"RetrievalToolbox.SimplePolynomialDispersion","text":"spectral_window::AbstractSpectralWindow: Spectral window\ncoefficients::Vector{T2} where T2<:AbstractFloat: Polynomial coefficients, ordered low to high\nindex::Vector{Int64}: Spectral samples within the current spectral window!\nww::Vector{T2} where T2<:AbstractFloat: Wavelengths corresponding to the index\ndetector_samples::AbstractRange: The full detector grid corresponding to the L1B spectral samples\nww_unit::Union{Unitful.Units{U, 𝐋} where U, Unitful.Units{U, 𝐋^-1} where U}: Unitful unit of all wavelength and coefficient quantities\n\nA type to represent a polynomial dispersion, where each spectral sample is related to wavelength or wavenumber through a polynomial of arbitrary degree.\n\n\n\n\n\n","category":"type"},{"location":"types/dispersion_types/#RetrievalToolbox.SimplePolynomialDispersion-Tuple{AbstractVector, AbstractRange, AbstractSpectralWindow}","page":"Dispersion Types","title":"RetrievalToolbox.SimplePolynomialDispersion","text":"Generates a SimplePolynomialDispersion object from a vector of polynomial coefficients (coeffs), some detector samples given as an AbstractRange object like 1:1016, (detector_samples), and a spectral window of type AbstractSpectralWindow that this dispersion object will refer to.\n\nSimplePolynomialDispersion(\n    coeffs::AbstractVector,\n    detector_samples::AbstractRange,\n    spectral_window::AbstractSpectralWindow\n) -> SimplePolynomialDispersion\n\n\n\n\n\n\n","category":"method"},{"location":"types/surface_types/#surface_types","page":"Surface Types","title":"Surface types","text":"","category":"section"},{"location":"types/surface_types/#RetrievalToolbox.BRDFSurface","page":"Surface Types","title":"RetrievalToolbox.BRDFSurface","text":"kernels::Vector{T} where T<:BRDFKernel\n\nType to hold a combination of BRDF Kernels\n\n\n\n\n\n","category":"type"},{"location":"types/surface_types/#RetrievalToolbox.LambertianPolynomialKernel","page":"Surface Types","title":"RetrievalToolbox.LambertianPolynomialKernel","text":"swin::AbstractSpectralWindow\norder::Int64\ncoefficients::Vector\n\nType that implements the Lambertian BRDF kernel for which the BRDF amplitude can be a spectrally varying polynomial of arbitrary order.\n\n\n\n\n\n","category":"type"},{"location":"types/surface_types/#RetrievalToolbox.LambertianPolynomialSurface","page":"Surface Types","title":"RetrievalToolbox.LambertianPolynomialSurface","text":"swin::AbstractSpectralWindow\norder::Int64\ncoefficients::Vector\n\nType to hold a Lambertian surface for which the amplitude can be a spectrally varying polynomial of arbitary order order.\n\n\n\n\n\n","category":"type"},{"location":"types/surface_types/#RetrievalToolbox.NoSurface","page":"Surface Types","title":"RetrievalToolbox.NoSurface","text":"Type to represent a lack of surface.\n\n\n\n\n\n","category":"type"},{"location":"types/surface_types/#RetrievalToolbox.RPVPolynomialKernel","page":"Surface Types","title":"RetrievalToolbox.RPVPolynomialKernel","text":"swin::AbstractSpectralWindow\norder::Int64\ncoefficients::Vector\nhotspot::Any\nasymmetry::Any\nanisotropy::Any\n\nType that implements the Rahman-Pinty-Verstraete BRDF kernel for which the BRDF amplitude can be a spectrally varying polynomial of arbitrary order. The other three parameters, hotspot asymmetry and anisotropy, are kept fixed throughout the spectral window which this surface is attached to.\n\n\n\n\n\n","category":"type"},{"location":"julia/units/#working_with_units","page":"Units","title":"Working with Unitful.jl units","text":"","category":"section"},{"location":"julia/units/#Introduction","page":"Units","title":"Introduction","text":"The retrieval toolkit currently uses Unitful.jl[Unitful] to attach physical units to various quantities that need them. This section here will present a short introduction to the package as well introduce helpful code snippets that should be used when working with RE. Some of these are currently used throughout the package to make sure that calculations are unit-aware.\n\nUnitful.jl introduces new types which allows users to perform calculations that respect the units of quantities of those types. For example, adding various length-type quantities triggers automatic unit conversions (using Unitful.jl is assumed for all code examples).\n\nusing Unitful # hide\n\n5.2u\"m\" + 123.5u\"inch\" - 0.005u\"mi\"\n\nPerforming e.g. an addition with quantities of incompatible units will raise an error.\n\nusing Unitful # hide\n10.0u\"m\" + 5.0u\"kg\"\n\nIn general, most types of numbers and arrays can be outfitted with a physical unit, and most basic computations with them will involve the automatic checks for compatible dimensions and, if needed, unit conversions.\n\nusing Unitful # hide\n[1., 2., 3., 4.] * u\"Pa\" + [0.05, 0.06, 0.07, 0.08] * u\"Torr\"\n\nNote that in the example above, the resulting quantity is not in units of Pascal, but in kg m⁻¹ s⁻², since Unitful.jl will usually default to SI units once a conversion has taken place. This behavior can be controlled, however, more details are found in the Unitful.jl documentation.\n\nOne can force unit conversion to any compatible unit via the uconvert function (note the broadcasting - uconvert does not dispatch on arrays or vectors).\n\nusing Unitful # hide\nx = [1., 2., 3., 4.] * u\"Pa\" + [0.05, 0.06, 0.07, 0.08] * u\"Torr\"\nuconvert.(Ref(u\"Pa\"), x)\n\nIn the example above, it is important to understand that the object x is a vector of pressure-type units. Julia allows for the mixing of types within a vector, so one can feasibly have a vector or array with mixed units. In this next example, we have three quantities of different units, although Julia will convert the quantities into Float64, even though the elements are initially typed as Float64, Float32 and Int64.\n\nusing Unitful # hide\n[1.0u\"m\", 5.0f0u\"kg\", 20u\"s\"]\n\nIn general, computations with Unitful-type arrays tend to be almost as fast as those with \"raw\" arrays of type Float32 or Float64. One of the exceptions is exponentiation with non-integer valued exponents, as shown below.\n\nusing Unitful # hide\nusing BenchmarkTools\n\nN = 16;\nA = rand(Float32, N, N);\nA_u = A * u\"Pa\";\n\n@benchmark A.^3.5 seconds=1\n@benchmark A_u.^3.5 seconds=1\n\nVarious linear algebra operations can be performed with Unitful quantities, such as the inverse of a square matrix, and the units of the returned object will be correct.\n\nusing Unitful # hide\n\nA = rand(5, 5) * u\"kg\";\ninv(A)\n\nOn the other hand, computing the QR-decomposition on such a matrix will fail.\n\nusing Unitful # hide\nusing LinearAlgebra\nA = rand(5, 5) * u\"kg\";\nqr(A)\n\nwarning: Warning\nMany functions, especially those that call lower-level routines (such as BLAS), might not be compatible with Unitful quantities, or arrays composed of them!\n\nWhile the result of certain linear algebra operations using matrices with physical units might make sense intuitively, others might not be well-defined. Further, it depends highly on the actual implementation and it is difficult to know whether a certain piece of Julia code will execute for a vector or matrix that has Unitful units attached to them.","category":"section"},{"location":"julia/units/#Usage-within-RetrievalToolbox","page":"Units","title":"Usage within RetrievalToolbox","text":"It is possible to use Unitful quantities directly in custom types and perform calculations using objects of those types. The convenience of this approach is clear: since every variable has units attached to them, an error will be raised immediately when an incompatible computation is performed. So if some part of a computation is accidentally mistyped and results in an operation that is not valid from a physical unit perspective, such as adding pressure and temperature, the code will not successfully execute. Further, if the computations themselves implicitly perform the required unit conversions, users do not need to write code that takes care of possible unit conversions. In addition to that, a flexible unit system allows users to choose their units of preference, e.g. state their pressures in \"hPa\" rather than \"Pa\".\n\nThere are currently two major drawbacks that were identified during the development of RetrievalToolbox when trying to use vectors and matrices of some Unitful type.\n\nSome linear algebra operations were fundamentally incompatible with Unitful matrices\nSome operations (e.g. exponentiation, taking the logarithm) suffered from performance drops\n\nRegarding (1), most computations can be performed with Unitful vectors and matrices without having to adapt the code. Various linear algebra operations, however, as is necessary for the inversion, require matrices that by definition have mixed units. If Unitful is consistently used for all quantities, then the prior covariance matrix for an OE-type retrieval, for example, will have various units for the quantities that occur within the matrix. While the inversion equations obviously are consistent in terms of their physical units, some of the linear algebra operations (e.g. computing the inverse of a larger matrix might use decomposition techniques) will fail since those tend to be optimized for numerical efficiency and might contain incompatible sub-operations. This issue can be circumvented by casting a Unitful matrix into a regular \"numeric\" matrix, performing the needed calculations, and then re-attaching the units at a later stage.\n\nA similar solution can be used for (2) by identifying which operations suffer from performance issues and making sure that those will be executed for regular matrices and vectors, rather than involving the Unitful types.\n\nThe current implementation of physical units in RetrievalToolbox uses a hybrid and more explicit approach. Every custom type with a field that should have a physical unit, also has a field that contains the physical unit. As an example, a GasAbsorber contains a volume mixing ratio profile vmr_levels. We want to give users the option to define a VMR profile in various units, such as ppb when working with methane, or ppm when working with carbon dioxide. So for the vmr_levels field, there is an accompanying field vmr_unit which carries the Unitful type that describes the physical unit.\n\nstruct GasAbsorber{T} <: AbstractAtmosphereElement where T\n\n    gas_name::String\n    spectroscopy::AbstractSpectroscopy\n    vmr_levels::Vector{T}\n    vmr_unit::Unitful.DimensionlessUnits\n\nend\n\nNote that above, we can not only demand that the user instantiate the object with a Unitful type, but we can also make sure that the assigned unit makes sense for this particular object. Volume mixing ratios should be dimensionless (or dimension 1), and Unitful provides a type that represents all the explicit types. There are many other types that fall into the same category, we can use e.g. Unitful.LengthUnits if we want to force any type of length unit.\n\nOf course now, users and code maintainers must use explicitly use the unit information and make sure that possible unit conversions are taken into account when they need to be. For dimensionless units, the situation is straightforward, since applying the NoUnits function will convert the dimensionless quantity into parts.\n\nUsers and code maintainers must ensure the appropriate use, and below we demonstrate the general idea with examples.\n\nFor example one, we have two dimensionless quantities x and y. Both x and y are Float64 in this case, and their associated units are stored in separate variables x_u and y_u. If we have to compute a new quantity x + y, we must first make sure the units of each are considered.\n\nusing Unitful # hide\n\nx = 1.234;\nx_u = u\"ppm\";\n\ny = 1500.0;\ny_u = u\"ppb\";\n\ny * y_u + x * x_u |> NoUnits\n\nIn the next example, we consider two pressure values p1 and p2 whose units p1_u and p2_u are not necessarily the same. Let us assume that we must carry on the computation in units of p2_u. The function ustrip provided by Unitful is very helpful in this way. When called with a Unitful quantity alone, the unit will be simply stripped, and the numeric value is retained, e.g. ustrip(123.0u\"hPa\") returns 123.0. However, when we call ustrip with a leading argument, being a compatible unit, the quantity will first be converted to that unit. ustrip(u\"Pa\", 123.0u\"hPa\") will return 12300.0.\n\nIn the first variant of performing p1 + p2, we first construct Unitful quantities by multiplying each pressure value by its respective unit, p1 * p1_u and p2 * p2_u, and then perform the sum. The intermediate sum will be in SI pressure units, but then we apply the ustrip function to convert the sum into units of p2_u and strip the unit to obtain the numerical value only.\n\nusing Unitful # hide\n#=\n    Version 1\n=#\np1 = 1100.0; p1_u = u\"hPa\";\np2 = 55.5; p2_u = u\"Pa\";\nresult = ustrip(p2_u, p1 * p1_u + p2 * p2_u)\n\nIn the second variant demonstrated here we first construct p1 * p1_u to obtain a Unitful object, which yields 1100.0 hPa, and immediately convert it into units of p2_u (Pa) and stripping the unit, such that this new variable tmp becomes 110000.0. Now we have pressure p1 as a numerical value in units of Pa (implicit), and can simply add it to p2 to obtain the same result as above.\n\nusing Unitful # hide\n#=\n    Version 2\n=#\np1 = 1100.0; p1_u = u\"hPa\";\np2 = 55.5; p2_u = u\"Pa\";\ntmp = ustrip(p2_u, p1 * p1_u);\nresult = p2 + tmp\n\nThroughout RetrievalToolbox both variants are applied.\n\n[Unitful]: https://github.com/PainterQubits/Unitful.jl","category":"section"},{"location":"types/RT_types/#RT_method_types","page":"Radiative Transfer Method Types","title":"Radiative Transfer Method Types","text":"","category":"section"},{"location":"types/RT_types/#RetrievalToolbox.BeerLambertRTMethod","page":"Radiative Transfer Method Types","title":"RetrievalToolbox.BeerLambertRTMethod","text":"scene::AtmosphereScene: AtmosphereScene for which the RT is to be computed\noptical_properties::AbstractOpticalProperties: AbstractOpticalProperties that provide the basic inputs for RT\nsolar_model::AbstractSolarModel: The solar model\nstate_vector::AbstractStateVector: The state vector\nhires_solar::Union{ScalarRadiance, VectorRadiance}: Buffer to hold the high-resolution solar irradiance\nhires_radiance::Union{ScalarRadiance, VectorRadiance}: Buffer to hold the high-resolution at-instrument radiance\nhires_jacobians::Union{Nothing, Dict{<:AbstractStateVectorElement, <:Union{ScalarRadiance, VectorRadiance}}}: Buffer to hold the high-resolution radiance Jacobians\nradiance_unit::Unitful.Units: Radiance unit\nsolar_scaler::AbstractVector: Solar scale array, to be multiplied into the solar irradiance\n\nAnalytic radiative transfer method for non-scattering atmospheres according to the Beer-Lambert-Bouguer law.\n\n\n\n\n\n","category":"type"},{"location":"types/RT_types/#RetrievalToolbox.MonochromaticRTMethod","page":"Radiative Transfer Method Types","title":"RetrievalToolbox.MonochromaticRTMethod","text":"model::Symbol: Which RT model to use, at the moment, only :XRTM is supported\nmodel_options::Union{Vector{T}, T} where T<:AbstractDict: Option dictionary to set parameters for the underlying RT code\nscene::AtmosphereScene: AtmosphereScene for which the RT is to be computed\noptical_properties::AbstractOpticalProperties: AbstractOpticalProperties that provide the basic inputs for RT\nsolar_model::AbstractSolarModel: The solar model\nstate_vector::AbstractStateVector: The state vector\nhires_solar::Union{ScalarRadiance, VectorRadiance}: Buffer to hold the high-resolution solar irradiance\nhires_radiance::Union{ScalarRadiance, VectorRadiance}: Buffer to hold the high-resolution at-instrument radiance\nhires_jacobians::Union{Nothing, Dict{SS, R1}} where {R1<:Union{ScalarRadiance, VectorRadiance}, SS<:AbstractStateVectorElement}: Buffer to hold the high-resolution radiance Jacobians\nhires_wfunctions::Union{Nothing, Vector{R1}} where R1<:Union{ScalarRadiance, VectorRadiance}: Buffer to hold the RT-computed weighting functions\nwfunctions_map::Dict{Any, Vector{Int64}}: Mapper dictionary to assign RT weighting functions to required Jacobians\nradiance_unit::Unitful.Units: Radiance unit\nsolar_scaler::AbstractVector: Solar scale array, to be multiplied into the solar irradiance\n\nGeneric monochromatic radiative transfer method to be used with external libraries, such as XRTM.\n\n\n\n\n\n","category":"type"},{"location":"functions/misc_functions/#Miscellaneous-functions","page":"Miscellaneous functions","title":"Miscellaneous functions","text":"Functions here are usually general \"helper\" or \"utility\" type functions that a likely used throughout different parts of RetrievalToolbox.","category":"section"},{"location":"functions/misc_functions/#RetrievalToolbox.FWHM_to_sigma-Tuple{Number}","page":"Miscellaneous functions","title":"RetrievalToolbox.FWHM_to_sigma","text":"FWHM_to_sigma(FWHM::Number) -> Any\n\n\nCalculates the standard deviation of a Gaussian for a given full width at half the maximum value.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.H2O_VMR_to_specific_humidity-Tuple{Number}","page":"Miscellaneous functions","title":"RetrievalToolbox.H2O_VMR_to_specific_humidity","text":"H2O_VMR_to_specific_humidity(h2o::Number) -> Any\n\n\nCalculates specific humidity from H2O VMR\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.check_for_not_finite-Tuple{AbstractArray}","page":"Miscellaneous functions","title":"RetrievalToolbox.check_for_not_finite","text":"check_for_not_finite(x::AbstractArray) -> Bool\n\n\nFor an array x, returns true if any element is not finite (as per isfinite), or false if all elements are finite.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.findany-Tuple{AbstractVector, Any}","page":"Miscellaneous functions","title":"RetrievalToolbox.findany","text":"findany(x::AbstractVector, a) -> Bool\n\n\nReturns true if a is found within x, does not allocate.\n\nExamples\n\njulia> findany([\"a\", \"b\", \"c\", \"d\"], \"b\")\ntrue\n\njulia> findany([1,2,3,4,5], 10)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.findanytype-Tuple{AbstractVector, Any}","page":"Miscellaneous functions","title":"RetrievalToolbox.findanytype","text":"findanytype(x::AbstractVector, T) -> Bool\n\n\nReturns true if any element within x is of type T, does not allocate.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.ingest!-Tuple{Any, Symbol, AbstractArray}","page":"Miscellaneous functions","title":"RetrievalToolbox.ingest!","text":"ingest!(obj, field::Symbol, val::AbstractArray)\n\n\nSets a RetrievalToolbox type field and applies the correct unit conversion. This is the specialized function to deal with array-type values. This should be mostlya allocation-free.\n\nDetails\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.ingest!-Tuple{Any, Symbol, Number}","page":"Miscellaneous functions","title":"RetrievalToolbox.ingest!","text":"ingest!(obj, field::Symbol, val::Number)\n\n\nSets a RetrievalToolbox type field and applies the correct unit conversion\n\nDetails\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.levels_to_layers!-Tuple{AbstractVector, AbstractVector}","page":"Miscellaneous functions","title":"RetrievalToolbox.levels_to_layers!","text":"levels_to_layers!(\n    layers::AbstractVector,\n    levels::AbstractVector;\n    logspace\n)\n\n\nFor a given level vector, calculate the mid-layer values and store into layers. This function assumes that the layer-value is evaluated at the center point between the two adjacent levels.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.levels_to_layers-Tuple{AbstractVector}","page":"Miscellaneous functions","title":"RetrievalToolbox.levels_to_layers","text":"levels_to_layers(levels::AbstractVector; logspace) -> Any\n\n\nFor a given level object, create a new vector that contains the mid-layer vector. This function assumes that the layer-value is evaluated at the center point between the two adjacent levels.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.maxmin-Tuple{AbstractArray}","page":"Miscellaneous functions","title":"RetrievalToolbox.maxmin","text":"maxmin(x::AbstractArray) -> Any\n\n\nFor an array x, returns the difference between the largest and smallest element maximum(x) - minimum(x).\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.pwl_value_1d_axb!-NTuple{5, Any}","page":"Miscellaneous functions","title":"RetrievalToolbox.pwl_value_1d_axb!","text":"a * b\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.specific_humidity_to_H2O_VMR-Tuple{Number}","page":"Miscellaneous functions","title":"RetrievalToolbox.specific_humidity_to_H2O_VMR","text":"specific_humidity_to_H2O_VMR(sh::Number) -> Any\n\n\nCalculates H2O VMR from specific humidity\n\n\n\n\n\n","category":"method"},{"location":"functions/instrument_functions/#Instrument-functions","page":"Instrument Functions","title":"Instrument functions","text":"RetrievalToolbox is mostly instrument-agnostic, meaning that none of the functions are written for specific instruments, even though a certain type of instrument class is assumed for the time being.\n\nNevertheless, in order to create a fully functioning retrieval algorithm, the forward model must be capable of producing instrument-level radiances. The functions listed below provide ways of doing so, assuming the high-resolution radiances and Jacobians have been calculated already.\n\nNote that some of the functions below may refer to quantities whose meaning should be understood in detail, for further reading consult Core Algorithm Concepts, especially the section on Pixels, Spectral Samples and Dispersion.","category":"section"},{"location":"functions/instrument_functions/#List-of-instrument-functions","page":"Instrument Functions","title":"List of instrument functions","text":"","category":"section"},{"location":"functions/instrument_functions/#RetrievalToolbox.apply_isrf_to_spectrum!-Tuple{InstrumentBuffer, GaussISRF, AbstractDispersion, AbstractVector, AbstractSpectralWindow}","page":"Instrument Functions","title":"RetrievalToolbox.apply_isrf_to_spectrum!","text":"apply_isrf_to_spectrum!(\n    inst_buf::InstrumentBuffer,\n    ISRF::GaussISRF,\n    disp::AbstractDispersion,\n    data::AbstractVector,\n    swin::AbstractSpectralWindow;\n    doppler_factor,\n    extend\n) -> Bool\n\n\nApplies the GaussISRF-type instrument response function on some vector data, usually intended to be the high-resolution model radiance or Jacobian. Integration limits are given by the extend keyword, it defines how many sigma (derived fom ISRF.FWHM) the integration limits are on both sides. The output is stored in inst_buf.low_res_output. Returns true if the calculation did not encounter any errors.\n\nDetails\n\nApplication of the ISRF is in accordance with standard literature. The radiance Is at instrument-level on a particular spectral sample s at wavelength lambda_s is given by\n\nIs = int I_mathrmmodel(lambda_s - Deltalambda) cdot mathrmISRF(Deltalambda)  dlambda\n\nwhere mathrmISRF is the Gaussian ISRF evaluated at the relative wavelength Deltalambda. This implementation replaces the integral by a fast numerical integration.\n\nInstrument Doppler shift\n\nThis function can take the doppler_factor argument, which is needed to compute the appropriate Doppler shift caused by the relative motion between, for example, the measurement footprint on the ground (for downlooking instruments) and the instrument along the line of sight. The Doppler factor is v  c where c is the speed of light. This function does not derive the appropriate Doppler shift, it is up to users to perform the appropriate calculation.\n\n\n\n\n\n","category":"method"},{"location":"functions/instrument_functions/#RetrievalToolbox.apply_isrf_to_spectrum!-Tuple{InstrumentBuffer, TableISRF, AbstractDispersion, AbstractVector, AbstractSpectralWindow}","page":"Instrument Functions","title":"RetrievalToolbox.apply_isrf_to_spectrum!","text":"apply_isrf_to_spectrum!(\n    inst_buf::InstrumentBuffer,\n    ISRF::TableISRF,\n    disp::AbstractDispersion,\n    data::AbstractVector,\n    spectral_window::AbstractSpectralWindow;\n    doppler_factor\n) -> Bool\n\n\nApplies the TableISRF-type instrument response function on some vector data, usually intended to be the high-resolution model radiance or Jacobian. The output is stored in inst_buf.low_res_output. Returns true if the calculation did not encounter any errors.\n\nDetails\n\nApplication of the ISRF is in accordance with standard literature. The radiance Is at instrument-level on a particular spectral sample s at wavelength lambda_s is given by\n\nIs = int I_mathrmmodel(lambda_s - Deltalambda) cdot mathrmISRF_s(Deltalambda)  dlambda\n\nwhere mathrmISRF_s is the pre-calculated ISRF (of sample s) evaluated at the relative wavelength Deltalambda. This implementation replaces the integral by a fast numerical integration via the trapezoid rule.\n\nThe output is stored in inst_buf.low_res_output.\n\nInstrument Doppler shift\n\nThis function can take the doppler_factor argument, which is needed to compute the appropriate Doppler shift caused by the relative motion between, for example, the measurement footprint on the ground (for downlooking instruments) and the instrument along the line of sight. The Doppler factor is v  c where c is the speed of light. This function does not derive the appropriate Doppler shift, it is up to users to perform the appropriate calculation.\n\n\n\n\n\n","category":"method"},{"location":"types/state_vector_types/#sv_types","page":"State Vector Types","title":"State Vector Types","text":"Certain components of RetrievalToolbox require an AbstractStateVector that controls the computation of quantities relevant to a retrieval algorithm. For example, during the calculation of optical properties, the routine scans through the supplied AbstractStateVector to decide whether certain partial derivatives are needed.\n\nState vector types can be understood as custom structures that only contain the most necessary information about them as needed in an optimal estimation-type retrieval algorithm, and variables of these types are self-descriptive. State vector elements dictate the behavior of functions that are employed in forward models. For example, the apply_radiance_correction! function is implemented for appropriate state vector elements. Somewhere in the forward model, it will be appropriate to alter the forward model calculation, depending on the state vector.\n\nThe code section below shows a simple example in which some radiance correction is applied to a state vector object state_vector. In this example, a loop runs through all state vector elements and the appropriate apply_radiance_correction! function is dispatched on the specific type of the state vector element object.\n\n# My forward model\n\n# [...]\n# Calculate radiances here\n# [...]\n\n# Apply radiance correction, depending on state vector\nfor sve in state_vector.state_vector_elements\n    RE.apply_radiance_correction!(buffer, sve)\nend\n\n# [...]\n\n\nThis way of writing a forward model makes use of Julia's multiple dispatch paradigm via which the most specific function will be called, if it is implemented. The strong benefit to users is that the forward model itself remains very legible, as no long conditional statements are needed to determine when to perform the required computation. The default implementation of the function in this example does nothing, so any state vector elements that should not induce any change in the forward model at this point, will act as expected.\n\nMore fundamentally, any forward model must incorporate the state vector its calculations through updating the state upon which the forward model acts. Users must implement necessary functionality themselves.  Since RetrievalToolbox does not provide a forward model per se, but rather provides the many components that users can utilize to build one, there are many functions which require a state vector type, as listed further in State Vector Functions.","category":"section"},{"location":"types/state_vector_types/#Retrieval-State-Vector","page":"State Vector Types","title":"Retrieval State Vector","text":"A RetrievalStateVector can be instantiated by passing a vector of  AbstractStateVectorElement variables.","category":"section"},{"location":"types/state_vector_types/#State-Vector-Element-(SVE)-Types","page":"State Vector Types","title":"State Vector Element (SVE) Types","text":"An AbstractStateVector consists of a list of state vector element (SVE) types, which are all subtypes of AbstractStateVectorElement. Every AbstractStateVectorElement type must be implemented as a mutable struct, due to the overall design of RE. Since instantiating new state vectors and state vector elements for each new retrieval scene would impact highly negatively on the overall performance, mutable structs are used. Once instantiated, users must make sure to reset each state vector element at the beginning of a new retrieval by setting the appropriate values and emptying out the iterations vector field with empty!(sve.iterations), with sve being the state vector element variable.","category":"section"},{"location":"types/state_vector_types/#Gas-scaling-factors","page":"State Vector Types","title":"Gas scaling factors","text":"For certain retrieval applications, it is sufficient to scale the volume mixing ratio profile of some target gas, rather than having to retrieve the full shape. The GasLevelScalingFactorSVE allows to define a section of the volume mixing ratio profile (or the full profile from top to bottom), which is adjusted during the retrieval.\n\nIf, for example, in a 10-level atmosphere set-up start_level and end_level are chosen to be (1, 5), then this SVE will only change the upper half of the gas VMR profile. To let this SVE scale the full profile, in this case the two values should be set to (1, 10), as the values are inclusive - inclusive meaning that the scale factor affects VMR profiles at levels 1,2,3,..,8,9,10. Multiple GasLevelScalingFactorSVE elements can appear in a state vector, each referencing a different portion of the atmosphere. As of now, there is no error catching mechanism, so users could define overlapping sections that will likely result in poor retrieval performance.\n\nWithin the calculations of optical properties, there are checks in place to determine whether partial derivatives of the optical properties with respect to volume mixing ratios are required. If a GasLevelScalingFactorSVE is part of the state vector, the partial derivatives of optical depth with respect to volume mixing ratio is automatically calculated.\n\nThis type requires a unit without dimensions, such as Unitful.percent or Unitful.NoUnits.\n\nnote: Note\nIn order for gas objects to be correctly updated, users must call the atmosphere_element_statevector_update! function as part of their forward model. Further, it is important to roll back the updates with the atmosphere_element_statevector_rollback! function towards the end of the forward model. For more details, consult following section in the manual: Updates and roll-backs.","category":"section"},{"location":"types/state_vector_types/#SIF-radiance","page":"State Vector Types","title":"SIF radiance","text":"Solar-induced fluorescence (SIF) can be co-retrieved in some circumstances where the retrieval window covers part of the range of SIF emission, roughly between 670 nm and 850 nm. If the model atmosphere has a SIFRadiance object in the list of AtmosphereElements, and the SIFRadianceSVE points to that object, then Jacobians are calculated and the SIF emission magnitude can be adjusted for during the inversion.\n\nwarning: Warning\nNote that the radiance units of the SIFRadianceSVE state vector element object, and the radiance unit of the SIFRadiance object need not be the same, as internal functions make appropriate conversions - however we highly recommend to not mix units of Watts and photons / s.\n\nThere is also no specific unit check for radiance-type units, so users must make sure themselves that the correct radiance-type unit is supplied, otherwise an error will be raised at some point when incompatible units clash during the calculation of the wavelength-dependent SIF radiance.","category":"section"},{"location":"types/state_vector_types/#Surface-pressure","page":"State Vector Types","title":"Surface pressure","text":"The atmospheric model in RetrievalToolbox, the surface pressure is equal to the lowest retrieval pressure level. Retrieving surface pressure through a SurfacePressureSVE allows shifting that lowest level. As with, e.g. the GasLevelScalingFactorSVE, the optical property routines will automatically perform the necessary calculations of partial derivatives that are needed to obtain the appropriate Jacobian. This state vector element provides the Jacobian that reflects a positive change of the lowest pressure level, i.e. partial I  partial p_N_mathrmlev.\n\nNote that there is no default or automatic adjustment of the retrieval pressure level grid that takes into account a possible surface pressure retrieval.\n\nwarning: Warning\nUsers must implement the adjustment of surface pressure into the retrieval grid themselves. A failure to do so will result in poor retrieval performance.\n\nThis state vector element requires a unit that is compatible with pressure (e.g. Pascal) which does not need to be the same unit as that of the retrieval pressure level grid. The code internally handles the conversion. Users could, for example, have a retrieval grid in Pascal, but retrieve the surface pressure in units of Torr.","category":"section"},{"location":"types/state_vector_types/#Surface-albedo-polynomial","page":"State Vector Types","title":"Surface albedo polynomial","text":"For a Lambertian surface model, in particular a LambertianPolynomialSurface, users can retrieve the polynomial coefficients. This state vector element has to be attached to a spectral window, since surfaces themselves are attached to a spectral window. Like all polynomial-related quantities, any state vector element must relate to a particular coefficient order. A convenience constructor exists which populates the unit field appropriately, given the coefficient order. One might call, for example\n\nRE.SurfaceAlbedoPolynomial(\n    swin, # Spectral window\n    2, # Polynomial order\n    u\"µm\", # Associated unit\n    0.0, # First guess\n    0.0, # Prior value\n    0.0, # Prior covariance\n)\n\nwhere the appropriate unit u\"µm^-2\" will be generated automatically, and the user must only supply some unit that is compatible with the spectral unit of the spectral window, i.e. a length unit for wavelengths, or a wavenumber unit for wavenumbers. An error will be thrown if units are incompatible.\n\nThis state vector element creates a wavelength-dependent quantity and uses the reference wavelength given by the linked spectral window. When calculating the surface reflectivity via calculate_surface_reflectivity!, the specialized function calculate_Lambertian_surface_reflectivity! computes the per-wavelength albedo using the relative wavelength lambda - lambda_mathrmref or relative wavenumber nu - nu_mathrmref.\n\nIn order to update the surface(s) given some state vector, a helper function exists which performs the in-place update within a RE.EarthScene object: RE.surfaces_statevector_update!.","category":"section"},{"location":"types/state_vector_types/#Dispersion-polynomial","page":"State Vector Types","title":"Dispersion polynomial","text":"","category":"section"},{"location":"types/state_vector_types/#Zero-level-offset-polynomial","page":"State Vector Types","title":"Zero level offset polynomial","text":"","category":"section"},{"location":"types/state_vector_types/#RetrievalToolbox.RetrievalStateVector","page":"State Vector Types","title":"RetrievalToolbox.RetrievalStateVector","text":"state_vector_elements::Vector{AbstractStateVectorElement}\n\nA type to hold a collection of state vector elements for use in a retrieval.\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#RetrievalToolbox.GasLevelScalingFactorSVE","page":"State Vector Types","title":"RetrievalToolbox.GasLevelScalingFactorSVE","text":"start_level::Int64: Start index of the sub-column (inclusive)\nend_level::Int64: Stop index of the sub-column (inclusive)\ngas::GasAbsorber: The gas object whose volume mixing ratio is scaled\nunit::Unitful.Units{U, NoDims} where U: Require dimensionless unit (e.g. Unitful.percent, or u\"1\")\nfirst_guess::Any: First guess value\nprior_value::Any: Prior value\nprior_covariance::Any: Prior covariance value\niterations::Vector: Vector to hold per-iteration values\n\nA type to represent a state vector element which scales a gas profile sub-column at the retrieval grid by its current value. start_level must be lower value (higher up in the atmosphere) than the end_level.\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#RetrievalToolbox.SIFRadianceSVE","page":"State Vector Types","title":"RetrievalToolbox.SIFRadianceSVE","text":"SIF::AbstractSIFRadiance\nunit::Unitful.Units\nfirst_guess::AbstractFloat\nprior_value::AbstractFloat\nprior_covariance::AbstractFloat\niterations::Vector{T} where T<:AbstractFloat\n\nState factor type for SIF radiance. This controls the radiance_at_reference field of the SIF object that is referenced here.\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#RetrievalToolbox.SurfacePressureSVE","page":"State Vector Types","title":"RetrievalToolbox.SurfacePressureSVE","text":"unit::Unitful.Units{U, 𝐌 𝐋^-1 𝐓^-2} where U: Require pressure units (e.g. Pa, Torr, hPa, ..)\nfirst_guess::AbstractFloat\nprior_value::AbstractFloat\nprior_covariance::AbstractFloat\niterations::Vector{T} where T<:AbstractFloat\n\nState factor type for surface pressure retrieval\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#RetrievalToolbox.SurfaceAlbedoPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.SurfaceAlbedoPolynomialSVE","text":"swin::AbstractSpectralWindow: Spectral window to which this SVE is attached to\ncoefficient_order::Int64: Polynomial coefficient order (0-indexed, order 0 means constant)\nunit::Unitful.Units: Depending on the coefficient order \"o\", this unit should be L^{-o}\nfirst_guess::AbstractFloat: First guess value\nprior_value::AbstractFloat: Prior value\nprior_covariance::AbstractFloat: Prior covariance value\niterations::Vector{T1} where T1<:AbstractFloat: Vector to hold per-iteration values\n\nState vector type for Lambertian surface albedo polynomials\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#RetrievalToolbox.DispersionPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.DispersionPolynomialSVE","text":"dispersion::AbstractDispersion\ncoefficient_order::Int64\nunit::Union{Unitful.Units{U, 𝐋} where U, Unitful.Units{U, 𝐋^-1} where U}: Require unit of length or wavenumber\nfirst_guess::AbstractFloat\nprior_value::AbstractFloat\nprior_covariance::AbstractFloat\niterations::Vector{T} where T<:AbstractFloat\n\nState factor type for dispersion polynomial coefficient retrieval\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#RetrievalToolbox.ZeroLevelOffsetPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.ZeroLevelOffsetPolynomialSVE","text":"swin::AbstractSpectralWindow: Spectral window to which this SVE is attached to\ncoefficient_order::Int64: Polynomial coefficient order (0-indexed, order 0 means constant)\nww_unit::Unitful.Units: Depending on the coefficient order \"o\", this unit should be L^{-o}\nunit::Union{Real, Unitful.Units}: Full unit\nfirst_guess::AbstractFloat: First guess value\nprior_value::AbstractFloat: Prior value\nprior_covariance::AbstractFloat: Prior covariance value\niterations::Vector{T1} where T1<:AbstractFloat: Vector to hold per-iteration values\n\nState vector type for zero level offset polynomials\n\n\n\n\n\n","category":"type"},{"location":"functions/atmosphere_functions/#Atmosphere-functions","page":"Atmosphere Functions","title":"Atmosphere functions","text":"Functions below are designed to operate on atmosphere object, and for the time being mostly on EarthAtmosphere ones.","category":"section"},{"location":"functions/atmosphere_functions/#Updates-and-roll-backs","page":"Atmosphere Functions","title":"Updates and roll-backs","text":"Atmosphere objects, just as EarthAtmosphere, are generally mutated during the course of an inverse retrieval problem. There is no \"history\" per se that would allow to unambiguously re-create the atmospheric state at some earlier iteration. Due to the flexibility of the toolset, it is always possible to make changes (intentional or not) to the atmospheric state that would be difficult to revert.\n\nThe mechanism that is used in RetrievalToolbox relies on user discipline. Let atm be an EarthAtmosphere that has been initialized and adjusted to the user's wishes, and let SV be a RetrievalStateVector that contains state vector elements that imply some modification of the contents of atm.\n\nFor some parts of the atmosphere, their state can be easily and directly inferred from a state vector element. As an example we can look at SurfacePressureSVE: the lowest pressure level is simply set to the current value of that state vector element via the atmosphere_element_statevector_update! function. One can think of the surface pressure of the model atmosphere being quite rigidly controlled, it will simply take on whatever value SurfacePressureSVE currently has. This allows us to also recreate the surface pressure that was present at an earlier iteration. We could manipulate the contents of the .iterations field of the SurfacePressureSVE object, i.e. remove entries up to the requested iteration number. When we call atmosphere_element_statevector_update! again, the atmosphere will revert back to that earlier state.\n\nThe above holds true for many state vector elements that control the atmospheric state, like the GasVMRProfileSVE which defines the volume mixing ratio profile of a certain gas in that model atmosphere, or SIFRadianceSVE which defines the magnitude of surface-leaving fluorescence radiance emission.\n\nThere are notable exceptions, for which this concept does not work - at least not reliably. GasLevelScalingFactorSVE, for example, scales the initial gas profile by some factor. Similarly, TemperatureOffsetSVE adds some value to the initial temperature profile. While it is mathematically straightforward to reconstruct the these profiles from the implicit history of iterations that is found in the .iterations vectors of these state vector elements, it has proven to be not fully reliable in practice.\n\nInstead, RetrievalToolbox expects users to to call a function atmosphere_element_statevector_rollback! towards the end of their forward model implementation, which re-sets particular atmospheric components to their initial state. Therefore, when a new forward model evaluation is performed, the call to atmosphere_element_statevector_update! will modify those components correctly to the desired state as given by the state vector elements.\n\nwarning: Warning\nImportant! There is no mechanism to check if the update and rollback functions have been called in a forward model. It is fully up to users to ensure that those calls are made in the forward model in the appropriate places.\n\nTo summarize, users should make a call to atmosphere_element_statevector_update! towards the beginning of their forward model, and then another call to atmosphere_element_statevector_rollback! towards the end.\n\n# My forward model\n\n# [...]\nfor atm_e in atm.atm_elements\n    RE.atmosphere_element_statevector_update!(atm_e, SV)\nend\n\n# [...]\n# calculate radiances, Jacobians etc.\n# [...]\n\nfor atm_e in atm.atm_elements\n    RE.atmosphere_element_statevector_rollback!(atm_e, SV)\nend\n\n# [...]\n# forward model end\n\ntip: Tip\nUsers also must ensure that atmosphere_element_statevector_update! is called after iterations are complete if they want to e.g. calculate some atmospheric quantity corresponding to the final state inferred by the retrieval.\n\nNote that the code snipped shows explicit loops over all atmosphere elements atm_e of some atmosphere atm.","category":"section"},{"location":"functions/atmosphere_functions/#List-of-atmosphere-functions","page":"Atmosphere Functions","title":"List of atmosphere functions","text":"","category":"section"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.JPL_gravity-Tuple{Number, Number}","page":"Atmosphere Functions","title":"RetrievalToolbox.JPL_gravity","text":"JPL_gravity(\n    latitude::Number,\n    altitude::Number;\n    earth_equatorial_radius\n) -> Any\n\n\nCalculates local gravity given some latitude and altitude. Note that the altitude can be be a simple number, in which the input is assumed to be in meters. If you supply a Unitful quantity, appropriate unit conversions are done. In either case, this function will return a Unitful quantity that will reduce to acceleration [m s⁻²].\n\nDetails\n\nThis code was taken from MS3 / the CSU simulator suite, with heritage related to the OCO-1 retrieval algorithm written at JPL. See https://github.com/nasa/RtRetrievalFramework at ./lib/implementation/altitude_hydrostatic.cc.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_rollback!-Tuple{AbstractAtmosphereElement, AbstractStateVectorElement}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_rollback!","text":"atmosphere_element_statevector_rollback!(\n    atm_element::AbstractAtmosphereElement,\n    sve::AbstractStateVectorElement\n) -> Any\n\n\nDefault behavior: do nothing\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_rollback!-Tuple{GasAbsorber, GasLevelScalingFactorSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_rollback!","text":"atmosphere_element_statevector_rollback!(\n    atm_element::GasAbsorber,\n    sve::GasLevelScalingFactorSVE\n) -> Any\n\n\nRolls back the GasAbsorber volume mixing ratio profile to its first-guess state as defined in sve.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Tuple{AbstractAtmosphereElement, AbstractStateVectorElement}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_element::AbstractAtmosphereElement,\n    sve::AbstractStateVectorElement\n) -> Any\n\n\nDefault function to update the atmosphere element atm_element according to the current value of the state vector element sve. This does nothing!\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Tuple{GasAbsorber, GasLevelScalingFactorSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_element::GasAbsorber,\n    sve::GasLevelScalingFactorSVE\n) -> Any\n\n\nUpdates the GasAbsorber volume mixing ratio profile according to sve.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Tuple{GasAbsorber, GasVMRProfileSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_element::GasAbsorber,\n    sve::GasVMRProfileSVE\n) -> Any\n\n\nUpdates atmospheric element atm_element if a GasVMRProfileSVE is present.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Tuple{SIFRadiance, SIFRadianceSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_element::SIFRadiance,\n    sve::SIFRadianceSVE\n) -> Union{Nothing, AbstractFloat}\n\n\nUpdates atmospheric element atm_element if a SIFRaidnaceSVE is present.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Union{Tuple{T}, Tuple{Vector{T}, AbstractStateVector}} where T<:AbstractAtmosphereElement","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_elements::Array{T<:AbstractAtmosphereElement, 1},\n    SV::AbstractStateVector\n)\n\n\nFunction to update all atmosphere elements in the vector atm_elements according to the current value of all state vector elements in the state vector SV.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_statevector_rollback!-Tuple{AbstractAtmosphere, TemperatureOffsetSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_statevector_rollback!","text":"atmosphere_statevector_rollback!(\n    atm::AbstractAtmosphere,\n    sve::TemperatureOffsetSVE\n) -> Any\n\n\nRolls back the atmosphere atm for a TemperatureOffsetSVE state vector element.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_statevector_update!-Tuple{AbstractAtmosphere, TemperatureOffsetSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_statevector_update!","text":"atmosphere_statevector_update!(\n    atm::AbstractAtmosphere,\n    sve::TemperatureOffsetSVE\n) -> Any\n\n\nUpdates the atmosphere atm for a TemperatureOffsetSVE state vector element.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_altitude_and_gravity!-Tuple{EarthScene}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_altitude_and_gravity!","text":"calculate_altitude_and_gravity!(scene::EarthScene)\n\n\nCalculates altitude and gravity for an EarthScene, assuming that all other needed quantities have been inserted accordingly, namely: pressure levels, temperatures layers, specific humidity layers and location. Note! Layer-based values are calculated in this function call and overwrite existing values!\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_altitude_and_gravity_levels!-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Number, EarthLocation}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_altitude_and_gravity_levels!","text":"calculate_altitude_and_gravity_levels!(\n    z_levels::AbstractVector,\n    g_levels::AbstractVector,\n    p_levels::AbstractVector,\n    T_layers::AbstractVector,\n    SH_layers::AbstractVector,\n    p_surf::Number,\n    location::EarthLocation\n)\n\n\nCalculates altitude and gravity levels for Earth-type atmospheres, in-place. For now, this function over-writes altitude_levels and gravity_levels in units of m and m/s^2 respectively!\n\nDetails\n\nGiven some atmospheric inputs (p, T, q) and the scene latitude and altitude, this function calculates the altitude and gravity profiles (on levels) corresponding to the pressure levels. These outputs should then be used to construct atmosphere objects (EarthAtmosphere).\n\nAt this point, p_levels must be in [Pa], T_layers in [K], SH_layers in [1], and the location.altitude in [m]. Alternatively, Unitful arrays with units can be used.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_gravity_from_z!-Tuple{EarthAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_gravity_from_z!","text":"calculate_gravity_from_z!(atm::EarthAtmosphere; g)\n\n\nCalculates local gravity based on altitude levels. The optional argument g can be supplied if users want a latitude=dependent surface-level gravity. Otherwise the standard gravity g0 (9.80655 ms⁻²) is used. Note that g must be in compatible units of acceleration.\n\nDetails\n\nThe gravity g(z) at altitude z is calculated as\n\ng(z) = g cdot (fracR_eR_e + z)^2\n\nwhere R_e is the (mean) Earth radius and g is the assumed gravity at the surface.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_layers!-Tuple{EarthAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_layers!","text":"calculate_layers!(atm::EarthAtmosphere)\n\n\nIn-place calculation of mid-layer values for all relevant profiles in an EarthAtmosphere object (p, p MET, q, T, z, g).\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_xgas-Tuple{AbstractAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_xgas","text":"calculate_xgas(atm::AbstractAtmosphere; gas_name) -> Dict\n\n\nCalculates the XGAS from an AbstractAtmosphere atm.\n\nThe column-averaged dry-air mole fraction is calculated according to O'Dell et al., 10.5194/amt-5-99-2012. Note that the returned quantity comes with the same unit as defined in the GasAbsorber object, which defines the VMR levels of that particular gas.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_ACOS_pressure_grid-Tuple{Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_ACOS_pressure_grid","text":"create_ACOS_pressure_grid(\n    psurf::Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}\n) -> Vector\n\n\nCreates the ACOS-type pressure grid on 20 levels\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_UoL_pressure_grid-Tuple{Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_UoL_pressure_grid","text":"create_UoL_pressure_grid(\n    p_surf::Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U},\n    p_tropo::Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U};\n    N_total\n) -> Vector\n\n\nCreates the 'classic' University of Leicester-type pressure grid, based on the supplied surface pressure p_surf and the tropopause pressure p_tropo.\n\nDetails\n\nA pressure grid is generated with fixed 5 stratospheric levels. The sixth level is halfway between tropopause pressure and level 5, and the seventh level is the tropopause pressure itself. Finally, the remaining levels are evenly spaced between the tropopause and the surface pressure. The total number of pressure levels must be greater than 8 (default: 20). If the tropopause pressure is larger than 8000 Pa (i.e. higher in the atmosphere), levels 6 and 7 are then set to predefined values and the tropopause is then considered to be level 7.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_empty_EarthAtmosphere-Union{Tuple{U}, Tuple{Integer, Integer, Type{<:Real}}} where U","page":"Atmosphere Functions","title":"RetrievalToolbox.create_empty_EarthAtmosphere","text":"create_empty_EarthAtmosphere(\n    Nlev::Integer,\n    Nlev_met::Integer,\n    T::Type{<:Real};\n    pressure_unit,\n    met_pressure_unit,\n    temperature_unit,\n    specific_humidity_unit,\n    altitude_unit,\n    gravity_unit\n) -> EarthAtmosphere\n\n\nCreates an empty EarthAtmosphere object with the specified number of retrieval grid levels, meteorological grid levels, array type T as well as units for the profiles. This function takes optional arguments to define the units for the various profiles.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_example_atmosphere-Tuple{String, Integer}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_example_atmosphere","text":"create_example_atmosphere(\n    name::String,\n    Nlev::Integer;\n    T,\n    surface_pressure,\n    altitude,\n    is_example\n) -> EarthAtmosphere{Float64}\n\n\nCreates an EarthAtmosphere object based on some representative atmospheres that were extracted from NASA GMAO's MERRA2 reanalysis and Sourish Basu's CO2/CH4. Must provide the name of the example atmosphere name as well as the intended number of pressure levels for the retrieval grid, Nlev, to be filled out be the user later.\n\nOptional arguments are surface_pressure or altitude (must choose one or none, never both) to adjust the model atmosphere accordingly.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_example_gas_profile-Tuple{String, String, AbstractSpectroscopy, Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}}}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_example_gas_profile","text":"create_example_gas_profile(\n    name::String,\n    gas_name::String,\n    spec::AbstractSpectroscopy,\n    plevels::Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}};\n    is_example\n) -> GasAbsorber\n\n\nCreates a gas profile from an example atmosphere, and attaches it to a supplied spectroscopy object spec. Pressure levels must also be given, which have to match the retrieval pressure levels.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_level_from_midlayer-Tuple{Any}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_level_from_midlayer","text":"create_level_from_midlayer(q) -> Any\n\n\nCreates a level-based profile from one defined on middle-of-the-layer. Assumes that the mid-layer value is well-approximated by half the value of the layer-boundary values.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_pressure_weights-Tuple{AbstractAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_pressure_weights","text":"create_pressure_weights(\n    atm::AbstractAtmosphere;\n    N_sub\n) -> Any\n\n\nCalculates the pressure weights according to O'Dell et al. in 10.5194/amt-5-99-2012. Between layer boundaries, a sub-layer numerical integration is used to calculate the (1-q)  (g * M_mathrmdry) term, where N_sub determines the number of sub-layers. Note that this assumes that the gas concentrations vary linearly with pressure, as implemented in the function calculate_gas_optical_depth_profiles.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.get_gas_from_name-Tuple{EarthAtmosphere, String}","page":"Atmosphere Functions","title":"RetrievalToolbox.get_gas_from_name","text":"get_gas_from_name(\n    atm::EarthAtmosphere,\n    name::String\n) -> Union{Nothing, AbstractAtmosphereElement}\n\n\nGiven an atmosphere object, this function returns a reference to the gas object whose name is the same as some string name.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.list_example_atmospheres-Tuple{}","page":"Atmosphere Functions","title":"RetrievalToolbox.list_example_atmospheres","text":"list_example_atmospheres() -> Vector{String}\n\n\nLists all available example atmospheres that can be loaded with create_example_atmosphere.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.update_specific_humidity_from_H2O!-Tuple{EarthAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.update_specific_humidity_from_H2O!","text":"update_specific_humidity_from_H2O!(\n    atm::EarthAtmosphere\n) -> Bool\n\n\nUpdates the specific humidity profile of the atmosphere atm, if an H2O profile is available as an atmospheric element. Does not update gravity and altitude profiles!\n\n\n\n\n\n","category":"method"},{"location":"","page":"Main","title":"Main","text":"RetrievalToolbox is a software library written in pure Julia to facilitate building trace gas retrieval algorithms and related applications.\n\nAs a first stop, reading through the Fundamentals section will provide both a broad overview of the usage principles of RetrievalToolbox.\n\nThe Design section lays out the design philosophy of the software and can help new users to understand specific workings of RetrievalToolbox or how different functions interact with each other. Users will find explanations on how we utilize abstract types, how to deal with wavenumbers and wavelengths, how physical units are handled (and where not), and how users should think about writing a retrieval algorithm with RetrievalToolbox.\n\nTo users that are (relatively) new to Julia, we have also integrated a few documents that explains various concepts of Julia that are often used in RetrievalToolbox, such as the usage of dictionaries (see here), which may differ from other programming and scripting languages, or how physical units are considered (see here).\n\nIn the current version of the software library, the following are not (yet) supported:\n\nTrue infra-red radiative transfer that includes thermal emission\nLimb soundings","category":"section"},{"location":"julia/develop/#develop_RetrievalToolbox","page":"Develop","title":"How to develop or extend RetrievalToolbox","text":"Thanks to Julia's approach to user-defined types and functions that act on or use those types, it is very straightforward to extend the capabilities of RetrievalToolbox to users' own needs, without having to alter the RetrievalToolbox library itself.","category":"section"},{"location":"julia/develop/#Extending-RetrievalToolbox","page":"Develop","title":"Extending RetrievalToolbox","text":"Users can extend RetrievalToolbox for use in their own projects by adding or overwriting its existing functions. If wanted, these new functions can seamlessly propagate into the overall flow of functions within RetrievalToolbox. The following section will provide some examples that can be used as guidance.","category":"section"},{"location":"julia/develop/#Example-1:-A-user-function-that-involves-a-RetrievalToolbox-type","page":"Develop","title":"Example 1: A user function that involves a RetrievalToolbox type","text":"In this first example, we will simply create a new function to extend the functionality of RetrievalToolbox. This new function will make use of existing functions and types that RetrievalToolbox provides.\n\nLet the following be the task at hand:\n\ntip: Task\nWe want to write a function which calculates the total, isotropic solar-induced fluorescence (SIF) emission into the half hemisphere (towards the sky). The function will take a SIFRadiance type as argument, and simply produce the integral over the spectral dimensions and the positive half space.\n\nWe start off by creating a SIFRadiance object and just inspect the spectrally resolved isotropic radiance that it represents. Using the function get_SIF_radiance, we can simply obtain that emitted radiance for some given wavelength (or wavenumber).\n\nusing RetrievalToolbox; const RE = RetrievalToolbox\nusing Unitful\nusing Plots; default(titlefontsize=10, labelfontsize=8)\n\n# Create the SIF object with 1e-7 W/m2/sr/µm at a reference wavelength of 740nm.\nsif = RE.SIFRadiance(1.0e-7, u\"W/m^2/sr/μm\", 740.0, u\"nm\");\n\n# Make a plot for sake of visualization\nwl = collect(650.0u\"nm\":1.0u\"nm\":870u\"nm\")\nPlots.plot(\n    wl,\n    RE.get_SIF_radiance.(Ref(sif), wl),\n    label=nothing, size=(400, 200)\n)\nxlabel!(\"Wavelength\")\nylabel!(\"SIF radiance\\n($(sif.radiance_unit))\")\nPlots.savefig(\"develop_fig1.svg\"); closeall(); nothing # hide\n\n(Image: sif plot)\n\nTo get the spectrally integrated value, we only need to sample this emitted radiance waveform in spectral space and integrate with some appropriate technique (trapezoidal integration is sufficient here). Further, we then multiply the spectrally integrated value with 2pi to take care of the integration of the half-space, which is equal to 2pi steradians. Also note how we use various units to make sure that we get the correct units for the final result in Watts per square meter.\n\nThe function only takes one argument, sif, which must be of the sub-type AbstractSIFRadiance, which RetrievalToolbox exports.\n\nfunction SIF_integral(sif::T) where T<:RE.AbstractSIFRadiance\n\n    # Spectrally integrated value\n    int_value = 0. * u\"W/m^2/sr\"\n    for i in 2:length(sif.ww_waveform)\n\n        # Simply sample the waveform data underlying\n        # the `sif` object..\n        ww1 = sif.ww_waveform[i]\n        ww2 = sif.ww_waveform[i-1]\n\n        v1 = RE.get_SIF_radiance(sif, ww1) * sif.radiance_unit\n        v2 = RE.get_SIF_radiance(sif, ww2) * sif.radiance_unit\n\n        int_value += 0.5 * (v1 + v2) * (ww1 - ww2)\n    end\n\n    # Integrate over half-space (2π sr),\n    # we have to \"manually\" set the units to W/m^2 since\n    # `Unitful` likes to turn W into kg/m/s^2.\n    return (int_value * (2*pi*u\"sr\") |> u\"W/m^2\")\nend\n\nAnd we finally call the function to test it:\n\n# Amount emitted towards the sky per m^2 of surface area for the\n# `sif` object defined above.\nSIF_integral(sif)\n\nUsers can write a function like the above in a script, for example, and simply use it as needed in that particular .jl file. If users want something more lasting, since this might be a function they would use over and over again, they could write a new module and use that module in their applications:\n\nmodule MyNewModule\n\n    # import other module\n    using RetrievalToolbox\n    const RE = RetrievalToolbox\n\n    export SIF_integral # Make this function available to users of `MyNewModule`\n\n    # Add SIF function\n    function SIF_integral(sif::T) where T<:RE.AbstractSIFRadiance\n        # [...] relevant code\n    end\n\nend\n\nIn the example above, our function would be accessible via MyNewModule.SIF_radiance.\n\nTo summarize, we can easily add new functions that make use of existing RetrievalToolbox functions and thus extend the overall capability of the software library to meet our own specific needs. In this example, we do not need to change anything within RetrievalToolbox itself, we simple make use of the existing functions. Further, we can create new modules that provide our new function if we need to use them for many projects.","category":"section"},{"location":"julia/develop/#Example-2:-A-new-user-type-that-will-become-part-of-the-existing-RetrievalToolbox-type-hierarchy","page":"Develop","title":"Example 2: A new user type that will become part of the existing RetrievalToolbox type hierarchy","text":"A step up in complexity is the introduction of a new user type. For example, if some form of atmospheric constituent or atmospheric element is needed that is currently not supported in RetrievalToolbox.\n\nIn RetrievalToolbox, we have an existing type hierarchy that starts with AbstractAtmosphereElement, and then moves on to another abstract type. For example, the SIF object we have used in Example 1 is of type SIFRadiance, which itself is a type that belongs to the abstract type AbstractSIFRadiance that is an AbstractAtmosphereElement.\n\nBelow is a visual representation of the current type hierarchy for all AbstractAtmosphereElements.\n\nusing InteractiveUtils\nusing AbstractTrees\nAbstractTrees.children(x::Type) = subtypes(x)\nprint_tree(RE.AbstractAtmosphereElement)\n\ntip: Task\nA scenario that a user might face is the following. The currently implemented method to calculate the emitted SIF radiance is not exactly what some user wants, but instead prefers their own formulation. The task here is therefore to create a new, user-defined object that represents our own SIF, and then implement the appropriate functions that compute the radiance.\n\nFor the sake of simplicity, let us just assume our new SIF produces a constant radiance of 1mathrmWmathrmm^2mathrmsrmathrmµm between 700 nm and 750 nm. We start by defining our new type, which is similar to the SIFRadiance type found in src/types/sif_types.jl, however omits several fields: radiance_at_reference and ww_reference (no need to impose some spectrally dependent scaling), and waveform and itp fields (we have no need for the interpolation object that captures the shape of the SIF waveform). Also, we only allow wavelengths here (again, for simplicity). Our new SIF type shall be called MySIFRadiance:\n\nmutable struct MySIFRadiance <: RE.AbstractSIFRadiance\n\n    radiance_unit::Unitful.Units\n    ww_unit :: Unitful.LengthUnits\n    ww_waveform :: Vector\n\nend\n\nAlong with the type definition, it is also important to define an external constructor function:\n\nfunction MySIFRadiance(\n    radiance_unit::Unitful.Units,\n    ww_unit::Unitful.LengthUnits\n)\n\n    # Produce \"waveform\" grid\n    ww_waveform = [700.0u\"nm\", 750.0u\"nm\"] .|> ww_unit\n\n    return MySIFRadiance(\n        radiance_unit,\n        ww_unit,\n        ww_waveform\n    )\n\nend\n\nWith both these defined, we can create a new SIF object, which we shall call new_sif:\n\nnew_sif = MySIFRadiance(u\"W/m^2/sr/μm\", u\"nm\");\n\nNow, RetrievalToolbox provides a get_SIF_radiance function that we used earlier evaluate the SIF radiance at some wavelength or wavenumber. Let's try to use it here to get the SIF radiance (of new_sif, which is an object of our new type MySIFRadiance) at 725 nm:\n\nRE.get_SIF_radiance(new_sif, 725.0u\"nm\")\n\nThe above call fails: there is no get_SIF_radiance function that accepts a SIF object of type MySIFRadiance! This is very much intended behavior, since the get_SIF_radiance function that RetrievalToolbox provides only makes sense for SIFRadiance objects. We have to write our own! While generally we are free to choose the arguments for our own implementation, it is considered good practice to keep the same arguments. That way, our new user-defined function have a good chance of seamlessly integrating into function inside of RetrievalToolbox.\n\nimport RetrievalToolbox: get_SIF_radiance\n\nfunction RetrievalToolbox.get_SIF_radiance(\n    sif::MySIFRadiance, # Note that this is now `MySIFRadiance`\n    ww::Unitful.Length\n)\n\n    if (ww < sif.ww_waveform[1]) | (ww > sif.ww_waveform[end])\n        return 0.\n    else\n        return 1.0\n    end\n\nend\n\nNow that we have created a function that accepts our new SIF type MySIFRadiance, a call to get_SIF_radiance will use the correct method!\n\nRE.get_SIF_radiance(new_sif, 725.0u\"nm\")\n\nFurther, any uses of SIF_integral that are invoked with objects of the new SIF type MySIFRadiance will themselves make calls to the correct get_SIF_radiance. This is an important part of this example! We did not have to make any adjustments to SIF_integral at all, since we kept the same function signature in our new implementation of get_SIF_radiance. Julia recognizes, that we call SIF_integral with a new argument type (that being MySIFRadiance) and re-compiles the function.\n\nSIF_integral(new_sif)\n\nHere is a summary of the important steps when creating a new type that fits into the existing type hierarchy.\n\nnote: Summary\nInvestigate the RetrievalToolbox type hierarchy to understand where your new type fits in best.\nWrite the new type definition, making sure that you understand which type fields are potentially needed by other functions, or if they can safely omitted if they serve no purpose for your new type.\nWrite all needed functions to implement the desired behavior for your new type  a. This requires knowing which functions may use your new type. The Julia function methodswith can be useful in finding that out. E.g. methodswith(RE.SIFRadiance, RetrievalToolbox) will list all functions that have at least one SIFRadiance function argument.\nRun tests!","category":"section"}]
}
