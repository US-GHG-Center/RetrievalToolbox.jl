var documenterSearchIndex = {"docs":
[{"location":"concepts/fundamentals/#Fundamentals","page":"Fundamentals","title":"Fundamentals","text":"","category":"section"},{"location":"concepts/fundamentals/#How-to-build-a-retrieval-algorithm","page":"Fundamentals","title":"How to build a retrieval algorithm","text":"","category":"section"},{"location":"concepts/fundamentals/#Utilizing-Buffers","page":"Fundamentals","title":"Utilizing Buffers","text":"","category":"section"},{"location":"concepts/fundamentals/#Mutability-of-Objects","page":"Fundamentals","title":"Mutability of Objects","text":"","category":"section"},{"location":"concepts/radiance/#Working-with-radiance-types","page":"Radiance","title":"Working with radiance types","text":"","category":"section"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"There are, at the moment, two radiance types that users can utilize to store calculated or measured radiance: ScalarRadiance and VectorRadiance. Both very similar to generic arrays, in fact they inherit many of the properties and functions from Julia's arrays.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"Depending on the situation, users can work with ScalarRadiance when polarization does not need to be accounted for, or use the VectorRadiance type if polarization is needed. Note that as opposed to many other types, these radiance containers do not have a unit field, but that might change in future versions.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"The main idea is to use whichever type is most natural for the specific application. While it would have been possible to only use a single radiance type which considers all components of the Stokes vector, it would require users to pay attention to Stokes components Q and U without ever truly needing them.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"Both ScalarRadiance and VectorRadiance have only one field, named S which itself is the underlying array of some type T to store the radiance. For ScalarRadiance, S is a vector (intensity I only), and VectorRadiance, S is a 3-column array representing the I, Q and U components. Both radiance types possess appropriate accessor functions so users can use the more \"natural\" I, Q, U notation to access the Stokes components in addition to simply using the type field .S.","category":"page"},{"location":"concepts/radiance/#Basic-examples","page":"Radiance","title":"Basic examples","text":"","category":"section"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"For a very basic example, let us first generate some scalar radiance object using the internal constructor.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"using RetrievalToolbox # hide\nconst RE = RetrievalToolbox # hide\nT = Float64;\nN = 4;\ns = RE.ScalarRadiance(T, N)","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"s is now our radiance object, which only has one field, namely S, representing the intensity for some number of spectral indices.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"Similarly, we can create a vector radiance that represents the first three components of the Stokes vector:","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"v = RE.VectorRadiance(T, N)","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"Functions that manipulate radiance can easily access the Stokes components inside either s or v via the explicit dot syntax.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"s.I[:] .= 0.1;\nv.I[:] .= 0.2;\nv.Q[:] .= -0.3;\nv.U[:] .= 0.03;","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"The main reason why the underlying object .S is an Array/Vector-type for both is to facilitate highly performant operations. For now, RetrievalToolbox makes use of LoopVectorization.jl, which speeds up certain looped computations dramatically, and we can easily use e.g. the @turbo macro to wrap such loops. Having both radiance types look similar under the hood allows users to write fast functions that are agnostic to the type of radiance, and thus work for either. Yet, it is still possible to dispatch on a particular radiance type, so that specific calculations can be done according to whether some radiance object is a ScalarRadiance or a VectorRadiance","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"For example, let's write a function that simply doubles all components of a radiance object:","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"using LoopVectorization\n\nfunction double_rad!(r::Radiance)\n    @turbo for i in axes(r, 1) # Loop over spectral points\n        for j in axes(r, 2) # Loop over components (if applicable)\n            r.S[i,j] *= 2\n        end\n    end\nend\n\ndouble_rad!(s)\nshow(s)\ndouble_rad!(v)\nshow(v)","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"Note the following: first, we make sure that this function is only to be used on radiance types, so we use the Radiance type (which is simply a union between ScalarRadiance and VectorRadiance) to restrict the function argument r. Then, we write a @turbo-accelerated loop that stretches over two dimensions of r. Even for the one-dimensional scalar radiance s, a second dimension is accessible as long as that second dimension is accessed by the index [1], trying to access another index will lead to a BoundsError. Lastly we do not simply write r[i,j] *= 2, but explicitly state the underlying array object r.S and write r.S[i,j] *= 2. While both versions would work in this case, the @turbo macro would not be able to produce accelerated code if we omit the .S.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"note: Note\nWhen writing code to perform operations on or with some radiance object r, best performance is achieved when explicitly using the underlying array object r.S.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"The ability to write a two-dimensional loop body even for the one-dimensional scalar radiance is crucial and allows users to write radiance type-agnostic code. Mixing two radiance objects of different radiance type is also easy to do, but requires some more checks on the possible types. Note that as a conscious design decision, there are currently no arithmetic operations defined on radiance objects of different types, so users will have to explicitly write those operations. While one can perform e.g. additions on two radiance objects of the same type, operations on different types will generally fail.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"For example, the following works without issues","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"s + s","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"v - 2*v","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"This next example, however, will fail since the shapes are incompatible:","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"show(size(s))\nshow(size(v))\ns + v","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"When it so happens that two or more radiance objects have to be used in mathematical operations, a few simple checks can be done to make sure that compatible operations are performed.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"new_rad = VectorRadiance(T, N); # T,N from above..\nr1 = s; r2 = v; # or can use r1 = v; r2 = s;\n\n@views new_rad[:,1] = r1[:,1] + r2[:,1]; # Add intensity component (both have them)\n\nif r1 isa VectorRadiance\n@views new_rad[:,2:end] += r1[:,2:end]\nend\n\nif r2 isa VectorRadiance\n@views new_rad[:,2:end] += r2[:,2:end]\nend\nnew_rad","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"In general, the expectation is that users tend to know which radiance objects are vector radiances, and which ones are scalar radiances, so it should generally be possible to write explicit and performant code when e.g. scalar solar (ir)radiances are multiplied with top-of-atmosphere vector radiances. For rare cases where the type is not known, type checks like above can be used to make sure the operations will succeed regardless of the type.","category":"page"},{"location":"concepts/core_concepts/#Core-Algorithm-Concepts","page":"Core Concepts","title":"Core Algorithm Concepts","text":"","category":"section"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"note: Note\nWithin the RetrievalToolbox algorithm tools, an attempt is made to keep notation consistent as well as stick to more modern terminology. This approach occasionally overrides more antiquated terms, so various sections in the documentation will emphasize when a possible clash is expected.","category":"page"},{"location":"concepts/core_concepts/#Instrument-Spectral-Response-Function-(formerly-ILS)","page":"Core Concepts","title":"Instrument Spectral Response Function (formerly ILS)","text":"","category":"section"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"OCO ATBD","category":"page"},{"location":"concepts/core_concepts/#Pixels,-Spectral-Samples-and-Dispersion","page":"Core Concepts","title":"Pixels, Spectral Samples and Dispersion","text":"","category":"section"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"The distinction between pixels, samples and what dispersion describes occasionally causes confusion due to a lack of consistent terminology in publications or other various documents.","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"A pixel is considered to be a discrete unit on an instrument detector of any type (where appropriate). Some instruments aggregate pixels during the read-out process such that the data received does not truly reflect the physical detector elements. Other instruments do read out the detector on a native pixel level, however some form of processing is performed afterwards and the resulting data, as ingested by retrieval algorithms, can no longer considered to be per-pixel.","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"Retrieval algorithms, in general, act on calibrated, geo-located radiance data, often denoted as Level-1b (L1B, L1b). For hyperspectral data, there usually is at least one spectral dimension of that data such that when the data is extracted along that dimension, one obtains what is considered a spectrum. One spectrum thus has a discrete number of elements along its spectral axis and the spectral axis consists of spectral samples. Those spectral samples do not have to be identical with the underlying detector pixels. For most instruments, they are not. Even for instruments in which the detector pixels map 1:1 into spectral samples, it is a good choice to stay consistent in the terminology and refer to an element of a spectrum as spectral sample.","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"For a single spectrum I that is extracted from calibrated, geo-located radiance data, the spectral sample information can be written explicitly as I_s, with s being some index of its spectral dimension. I_s is naturally a discrete quantity with s being a discrete index itself. Compare this to a theoretical description of radiance, which in general is a continuous function of wavelength or wavenumber tildeI(lambda) or tildeI(nu). In order to allow for a comparison between measured quantity I_s and a model radiance, one must know which wavelength or wavenumber corresponds to a spectral sample at index s.","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"The relationship between spectral sample (index) and wavelength or wavenumber is usually called dispersion. An alternative term for dispersion is wavelength (wavenumber) solution. It is some general function d which maps a spectral sample index to either wavelength or wavenumber, whichever is appropriate for the specific instrument: d(s) = lambda_s or d(s) = nu_s. When d is known, it is straightforward to evaluate some continuous function tildeI at the correct wavelength or wavenumber in order to compare it to a measured value: I_s sim tildeIleft( d(s) right).","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"For many instruments, the function d is generally smooth and tends to be expressed as a polynomial which maps spectral sample to wavelength or wavenumber in the following way:","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"    lambda_s = sum_i=0^N c_i cdot s^i ","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"or","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"    nu_s = sum_i=0^N c_i cdot s^i","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"The polynomial coefficients c are usually either available in the published measurement data, in accompanying documents, or in rare cases, have to be derived.","category":"page"},{"location":"functions/state_vector_functions/#State-Vector-Functions","page":"State Vector Functions","title":"State Vector Functions","text":"","category":"section"},{"location":"functions/state_vector_functions/#Aerosol-Height","page":"State Vector Functions","title":"Aerosol Height","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{AerosolHeightSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::AerosolHeightSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to AerosolHeightSVE types should be calculate before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{AerosolHeightSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::AerosolHeightSVE) -> String\n\n\nReturns the name of this aerosol width state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.is_aerosol_SVE-Tuple{AerosolHeightSVE}","page":"State Vector Functions","title":"RetrievalToolbox.is_aerosol_SVE","text":"is_aerosol_SVE(sve::AerosolHeightSVE) -> Bool\n\n\nReturns whether this SVE (sve) is an aerosol-related SVE. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Aerosol-Optical-Depth","page":"State Vector Functions","title":"Aerosol Optical Depth","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{AerosolOpticalDepthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::AerosolOpticalDepthSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to AerosolOpticalDepthSVE types should be calculate before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{AerosolOpticalDepthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this aerosol OD state vector element as a string.\n\nget_name(sve)\n\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.is_aerosol_SVE-Tuple{AerosolOpticalDepthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.is_aerosol_SVE","text":"is_aerosol_SVE(sve::AerosolOpticalDepthSVE) -> Bool\n\n\nReturns whether this SVE (sve) is an aerosol-related SVE. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Aerosol-Width","page":"State Vector Functions","title":"Aerosol Width","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{AerosolWidthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(sve::AerosolWidthSVE) -> Bool\n\n\nReturns whether the Jacobian related to AerosolWidthSVE types should be calculate before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{AerosolWidthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::AerosolWidthSVE) -> String\n\n\nReturns the name of this aerosol width state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.is_aerosol_SVE-Tuple{AerosolWidthSVE}","page":"State Vector Functions","title":"RetrievalToolbox.is_aerosol_SVE","text":"is_aerosol_SVE(sve::AerosolWidthSVE) -> Bool\n\n\nReturns whether this SVE (sve) is an aerosol-related SVE. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#BRDF-Kernel-Polynomial","page":"State Vector Functions","title":"BRDF Kernel Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{BRDFPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::BRDFPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to BRDFPolynomialSVE types should be calculate before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{BRDFPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::BRDFPolynomialSVE) -> String\n\n\nReturns the name of this surface albedo state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Dispersion-Polynomial","page":"State Vector Functions","title":"Dispersion Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{DispersionPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::DispersionPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to DispersionPolynomialSVE types should be calculate before convolution happens. Returns false.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{DispersionPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::DispersionPolynomialSVE) -> String\n\n\nReturns the name of this dispersion state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Gas-VMR-Profile","page":"State Vector Functions","title":"Gas VMR Profile","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{GasVMRProfileSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::GasVMRProfileSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to GasVMRProfileSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{GasVMRProfileSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::GasVMRProfileSVE) -> String\n\n\nReturns the name of this dispersion state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.idx_for_profile_sve-Tuple{GasAbsorber, AbstractStateVector}","page":"State Vector Functions","title":"RetrievalToolbox.idx_for_profile_sve","text":"idx_for_profile_sve(\n    gas::GasAbsorber,\n    sv::AbstractStateVector\n) -> Vector{Integer}\n\n\nReturns the positional indices of state vector elements that are a GasVMRProfileSVE and belong to a GasAbsorber gas. This allows easy retrieval of the VMR profile SVEs for some gas\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Gas-Level-Scaling-Factor","page":"State Vector Functions","title":"Gas Level Scaling Factor","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{GasLevelScalingFactorSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::GasLevelScalingFactorSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to GasLevelScalingFactorSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{GasLevelScalingFactorSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::GasLevelScalingFactorSVE) -> String\n\n\nReturns the name of this dispersion state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#ILS-Stretch-Polynomial","page":"State Vector Functions","title":"ILS Stretch Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{ILSStretchPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::ILSStretchPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to ILSStretchPolynomialSVE types should be calculated before convolution happens. Returns false.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{ILSStretchPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::ILSStretchPolynomialSVE) -> String\n\n\nReturns the name of this ILS stretch state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Solar-Scaler-Polynomial","page":"State Vector Functions","title":"Solar Scaler Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{SolarScalerPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::SolarScalerPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to SolarScalerPolynomialSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{SolarScalerPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::SolarScalerPolynomialSVE) -> String\n\n\nReturns the name of this solar scaler polynomial state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Surface-Albedo-Polynomial","page":"State Vector Functions","title":"Surface Albedo Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{SurfaceAlbedoPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::SurfaceAlbedoPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to SurfaceAlbedoPolynomialSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{SurfaceAlbedoPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"get_name(sve::SurfaceAlbedoPolynomialSVE) -> String\n\n\nReturns the name of this surface albedo state vector element as a string.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Surface-Pressure","page":"State Vector Functions","title":"Surface Pressure","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{SurfacePressureSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::SurfacePressureSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to SurfacePressureSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{SurfacePressureSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this surface pressure vector element as a string.\n\nget_name(sve::SurfacePressureSVE) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Temperature-Offset","page":"State Vector Functions","title":"Temperature Offset","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{TemperatureOffsetSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::TemperatureOffsetSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to TemperatureOffsetSVE types should be calculated before convolution happens. Returns true.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{TemperatureOffsetSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this temperature offset state vector element as a string.\n\nget_name(sve::TemperatureOffsetSVE) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#Zero-Level-Offset-Polynomial","page":"State Vector Functions","title":"Zero Level Offset Polynomial","text":"","category":"section"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian!-Tuple{AbstractRTBuffer, ZeroLevelOffsetPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian!","text":"calculate_jacobian!(\n    rt_buf::AbstractRTBuffer,\n    sve::ZeroLevelOffsetPolynomialSVE\n) -> Any\n\n\nCalculates the Jacobian for a ZeroLevelOffsetPolynomialSVE\n\nDetails\n\nThe ZLO radiance offset at wavelength of spectral sample s (λ_s) is generally calculated as (and analogously for wavenumbers, ν_s)\n\nsum_i=0^O-1 c_i cdot (λ_s - λ_textref)^i\n\nwhere i runs from 0 up to O - 1, where O is the order of the polynomial. See also apply_radiance_correction! for this SVE type.\n\nThe partial derivative of the radiance I with respect to the polynomial coefficient c_i is then\n\nIc_i = (λ_s - λ_textref)^i\n\nThe reference spectral point (λ_textref or ν_textref) is given by the spectral window object that is attached to the sve as sve.swin.ww_reference. Unit differences between the rt_buf RT buffer and the unit of this sve are explicitly taken into account, so this sve may have any compatible radiance units as long as the converstion to the rt_buf.radiance_unit is valid.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_jacobian_before_isrf-Tuple{ZeroLevelOffsetPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_jacobian_before_isrf","text":"calculate_jacobian_before_isrf(\n    sve::ZeroLevelOffsetPolynomialSVE\n) -> Bool\n\n\nReturns whether the Jacobian related to ZeroLevelOffsetPolynomialSVE types should be calculated before convolution happens. Returns false since the partial derivative calculation does not need the resulting radiance itself.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.calculate_zlo!-Tuple{AbstractVector, Any, ZeroLevelOffsetPolynomialSVE, AbstractDispersion, AbstractVector}","page":"State Vector Functions","title":"RetrievalToolbox.calculate_zlo!","text":"calculate_zlo!(\n    output::AbstractVector,\n    radiance_unit,\n    sve::ZeroLevelOffsetPolynomialSVE,\n    dispersion::AbstractDispersion,\n    indices::AbstractVector\n)\n\n\nCalculates the per-sample zero-level offset as given by the state vector element sve and indexed by the dispersion dispersion. This function is called by apply_radiance_correction! and likely does not need to be done by the user.\n\n\n\n\n\n","category":"method"},{"location":"functions/state_vector_functions/#RetrievalToolbox.get_name-Tuple{ZeroLevelOffsetPolynomialSVE}","page":"State Vector Functions","title":"RetrievalToolbox.get_name","text":"Returns the name of this ZeroLevelOffsetSVE state vector element as a string.\n\nget_name(sve::ZeroLevelOffsetPolynomialSVE) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"types/atmosphere_types/#Atmosphere-types","page":"Atmosphere Types","title":"Atmosphere types","text":"","category":"section"},{"location":"types/atmosphere_types/","page":"Atmosphere Types","title":"Atmosphere Types","text":"An EarthAtmosphere object, as the name suggests, characterizes an atmospheric state on Earth with a number of profiles and other quantities to the extent needed by most models to generate radiances.","category":"page"},{"location":"types/atmosphere_types/","page":"Atmosphere Types","title":"Atmosphere Types","text":"Convenience functions exist which make the creation of EarthAtmosphere objects easier, such as create_empty_EarthAtmosphere or create_example_atmosphere.","category":"page"},{"location":"types/atmosphere_types/","page":"Atmosphere Types","title":"Atmosphere Types","text":"The concept of an atmospheric state supported by RetrievalToolbox is one that includes two categories of profiles. One type of profile is associated with the retrieval grid, a one-dimensional vertical pressure profile (pressure_levels) that dictates e.g. optical property calculations and also determines the pressures at which the gas profile values are defined. The second  type are the meteorological profiles, reserved for specific humidity, temperature, altitude and gravity. These are laid out on another pressure grid (met_pressure_levels) which can be a completely different one compared to the retrieval grid.","category":"page"},{"location":"types/atmosphere_types/","page":"Atmosphere Types","title":"Atmosphere Types","text":"Each profile has its own physical unit with denoted by _unit, so e.g. the altitude levels are stored in .altitude_levels, and the corresponding unit field is .altitude_unit. The type definition restricts the possible units to those that make sense physically, so users can use u\"km\" or u\"m\" as their physical units for the altitude profile, but not e.g. u\"Pa\", as that is not a valid length-type unit.","category":"page"},{"location":"types/atmosphere_types/","page":"Atmosphere Types","title":"Atmosphere Types","text":"When users write a retrieval algorithm that performs retrievals on many scenes, it is generally adviced to not create new atmosphere objects as that tends to fill up memory quite fast. Instead, use the ingest! function to copy values into the atmosphere object, over-writing existing values. As with most objects in RetrievalToolbox, users must be cautious as it is always possible to change values inside the object.","category":"page"},{"location":"types/atmosphere_types/#RetrievalToolbox.EarthAtmosphere","page":"Atmosphere Types","title":"RetrievalToolbox.EarthAtmosphere","text":"atm_elements::Vector{<:AbstractAtmosphereElement}: Vector of atmosphere elements present in this atmosphere\nN_level::Int64: Number of retrieval levels in this atmosphere\nN_layer::Int64: Number of retrieval layers in this atmosphere\npressure_levels::Vector{T} where T<:AbstractFloat: Pressure level locations\npressure_layers::Vector{T} where T<:AbstractFloat: Mid-layer pressure locations\npressure_unit::Unitful.Units{U, 𝐌 𝐋^-1 𝐓^-2} where U: Pressure unit\nN_met_level::Int64: Number of meteorological levels in this atmosphere\nN_met_layer::Int64: Number of meteorological layers in this atmosphere\nmet_pressure_levels::Vector{T} where T<:AbstractFloat: Meteorological pressure level locations\nmet_pressure_layers::Vector{T} where T<:AbstractFloat: Mid-layer pressure locations for meteorology\nmet_pressure_unit::Unitful.Units{U, 𝐌 𝐋^-1 𝐓^-2} where U: Pressure units for meteorology\ntemperature_levels::Vector{T} where T<:AbstractFloat: Temperatures at pressure levels\ntemperature_layers::Vector{T} where T<:AbstractFloat: Temperatures at mid-layer pressures\ntemperature_unit::Unitful.Units{U, 𝚯, nothing} where U: Temperature unit\nspecific_humidity_levels::Vector{T} where T<:AbstractFloat: Specific humidity at pressure levels\nspecific_humidity_layers::Vector{T} where T<:AbstractFloat: Specific humidity at mid-layer pressures\nspecific_humidity_unit::Unitful.Units{U, NoDims} where U: Specific humidity unit\naltitude_levels::Vector{T} where T<:AbstractFloat: Altitude at pressure levels\naltitude_layers::Vector{T} where T<:AbstractFloat: Altitude at mid-layer pressures\naltitude_unit::Unitful.Units{U, 𝐋} where U: Altitude units\ngravity_levels::Vector{T} where T<:AbstractFloat: Gravity at pressure levels\ngravity_layers::Vector{T} where T<:AbstractFloat: Gravity at mid-layer pressures\ngravity_unit::Unitful.Units{U, 𝐋 𝐓^-2} where U: Gravity unit\n\n\n\n\n\n","category":"type"},{"location":"design/design/#Toolkit-design-philosophy","page":"Design","title":"Toolkit design philosophy","text":"","category":"section"},{"location":"design/design/#Namespace","page":"Design","title":"Namespace","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"The RetrievalToolbox module exports many functions, types and variables - some of those might share names with functions from other modules or your own user code. While not strictly necessary, we generally recommend to load the module and then declare an alias to then call the module functions through it.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"using RetrievalToolbox\nconst RE = RetrievalToolbox\n\nRE.some_function()\n\n# this, however, works too\nsome_function()","category":"page"},{"location":"design/design/#Reliance-on-Julia-types","page":"Design","title":"Reliance on Julia types","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"One of Julia's most prominent features is the flexibility that comes with its rich type system. While not object-oriented in the sense that C++ is, objects, their relationship to functions, and how they act on specific objects is a major design component of Julia and thus RetrievalToolbox.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"RetrievalToolbox defines a number of abstract types and then lots of composite types, which are akin to struct types in C. They usually sit below abstract types in the type hierarchy and represent some granular concept that is useful for trace gas retrievals.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"For example, the GaussAerosol type belongs to the AbstractAerosolType which itself belongs to AbstractAtmosphereElement, and describes some aerosol whose vertical distribution in the model atmosphere is described by a Gaussian. The full type hierarchy here is GaussAerosol ⊂ AbstractAerosolType ⊂ AbstractAtmosphereElement. When users create a model atmosphere, they must add some AbstractAtmosphereElement to the list of atmosphere elements. At that stage, we do not care what specific object that might be, as long as it satisfies the requirement that it has to be a type that is a subtype of AbstractAtmosphereElement.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Now how does Julia's type system and the multiple dispatch paradigm help us here. First, it allows for some convenience. We can use some list of atmospheric elements that we want represented in our model atmosphere: aerosols and Rayleigh scattering. Those two are quite different in practical terms, even though they might act in similar ways on our various calculations. So if we have some list of AbstractAtmosphereElement objects","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"atm_list = [aerosol1, aerosol2, RayleighScattering()]","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"we would ideally want to perform some action with each of those elements, such as calculating their contribution to the optical depth profiles of our model atmosphere. Some naïve way of doing that would be to iterate through each element and perform the appropriate action:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"for atm in atm_list\n    if is_an_aerosol(atm)\n        tau = calculate_gauss_aerosol_tau(atm)\n    end\n\n    if is_Rayleigh_scattering(atm)\n        tau = calculate_Rayleigh_tau(atm)\n    end\n\n    # .. do something with tau\nend","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"This is easily done with Julia, but makes this top-level iteration not very elegant. One can imagine that if we implement several aerosol distribution types, this loop will grow since we want to call the dedicated function to perform the wanted operation. The preferred way in Julia is making use of multiple dispatch: we decide on a name for a function that shall perform the equivalent task for different types. Let us call this function calculate_tau:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"for atm in atm_list\n    tau = calculate_tau(atm)\n    # .. do something with tau\nend","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"and as long as there is a function calculate_tau which implements the calculate for the requested type, above code will execute and keep this top-level loop nice and tidy.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"While the above example allows for some convenience, the strength of multiple dispatch also lies in how users can expand code without having to change code deep within a module they use. For example, let us imagine a new aerosol type that a user wants to integrate in their retrieval application: MyAerosolType. A new list of atmosphere elements would be created, like so","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"my_new_aerosol = MyAerosolType()\natm_list = [aerosol1, aerosol2, RayleighScattering(), my_new_aerosol()]","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Now in this imagined scenario, the user can now create their own calculate_tau function, which would implement the specific routine that computes the optical depth profiles for their new aerosol type:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"function calculate_tau(a::MyAerosolType)\n    # Do many calculations here...\n    # ...\nend","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When done correctly, the new function will be invoked when the loop above runs (for atm in atm_list ...)  since the Julia compiler will now look for a calculate_tau function that can act on an object of type MyAerosolType.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"To summarize: RetrievalToolbox makes extensive use of Julia's type system such that many functions in the module do not act on primitive types (like numbers or strings), but on custom composite types.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"info: Info\nThe Julia type system allows for flexibility in creating program code that looks the same for a variety of object types. Further, users can more easily extend existing code with their own types without necessarily having to change the underlying routines, but by providing their own user code.","category":"page"},{"location":"design/design/#Buffers-for-performance","page":"Design","title":"Buffers for performance","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"Julia is a garbage-collected language (more detailed info here), meaning that users do not have explicit control over how and when objects are de-allocated from memory. When users write functions that allocate (by creating vectors and arrays, for example), the memory is not immediately freed when the function is completed. The garbage collector (GC) is triggered at some point when the memory usage reaches some level. The GC then traces through the objects in memory and removes those that are no longer used.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"The big advantage of GC-based languages is of course that manual memory management is no longer needed, and users do not have to keep track of correct allocation and de-allocation of objects, and memory safety issues are also less common. The major downside is that without manual memory management, users could (un)willingly write code that very inefficiently allocates a lot of memory. When those allocations happen in certain places (loops mostly), memory will fill up quickly and trigger GC sweeps very often. The paradigm within Julia is usually: allocate arrays and vectors beforehand, and perform calculations on these pre-allocated objects.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Early versions of RetrievalToolbox did not make use of much pre-allocation, and most calls to functions would create new objects. This has proven to be not a feasible solution. While convenient for top-level scripting, the many allocations needed made it impossible to run faster retrievals where the forward model run was much less than a second (e.g. physics-based SIF retrievals or other non-scattering applications).","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Thus, we make use of pre-allocated objects, which we call buffers here.","category":"page"},{"location":"design/design/#Order-of-instantiation-in-a-retrieval-algorithm","page":"Design","title":"Order of instantiation in a retrieval algorithm","text":"","category":"section"},{"location":"design/design/#Executing-the-forward-model-will-mutate-some-objects","page":"Design","title":"Executing the forward model will mutate some objects","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"Kinda bad for e.g. gas scale factors that mean factors of some initial atmospheric state.","category":"page"},{"location":"design/design/#Explicit-and-lengthy-or-simplified-and-short?","page":"Design","title":"Explicit and lengthy or simplified and short?","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"Explain why some code sections look explicitly verbose and long, and why making it shorter and less verbose is an option - sometimes.","category":"page"},{"location":"design/design/#Wrapper-functions-and-specific-dispatch","page":"Design","title":"Wrapper functions and specific dispatch","text":"","category":"section"},{"location":"design/design/#Considering-quantities-with-physical-units","page":"Design","title":"Considering quantities with physical units","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"Explain types and dedicated type fields for units. Pay attention to supplying quantities with the right units!","category":"page"},{"location":"design/design/#Wavelengths-and-wavenumbers","page":"Design","title":"Wavelengths and wavenumbers","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"RetrievalToolbox supports two fundamental spectral unit types: wavelength and wavenumber. Users might want to build an algorithm pipeline that is specific to some instrument, which natively produces spectra in either wavelength or wavenumber units. In order to make the native spectral unit be visible as such, RetrievalToolbox provides dynamic accessors which allow users to reference the spectral unit of objects using their natural wording or symbol.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Rather than writing duplicate types and functions, RetrievalToolbox employs magic accessor methods. Any quantity that represents a spectral unit, is typed ww or, for example, ww_unit or ww_reference. The two-letter combination ww is thus reserved in the RetrievalToolbox codebase, and no type fields should contain this combination of letters.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"The ww should be considered a placeholder, which represents either a wavelength- or a wavenumber-related quantity. Any type that contains a field or quantity ww must also contain a field named ww_unit. Other fields are optional.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When the RetrievalToolbox module is imported, all types inside the RetrievalToolbox namespace are scanned for type fields that contain the substring ww. For each type that contains such a field, a new accessor function is dynamically created, which allows users to access the spectral type fields with the appropriate symbol. Illustrative examples follow.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Creating a spectral window object from 1.49 µm through 1.55 µm with 10 nm spacing could, for example, look like this (with loaded Unitful):","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"using RetrievalToolbox # hide\nconst RE = RetrievalToolbox # hide\nusing Unitful # hide\n\nswin = RE.SpectralWindow(\n    \"test\",\n    1.49, # Lower limit\n    1.55, # Upper limit\n    collect(1.48:0.01:1.56), # Create the grid with spacing\n    Unitful.µm, # Designate microns as unit of choice\n    1.50 # Set some reference wavelength\n    )","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"As can be seen in the type definition, the spectral grid can be accessed via swin.ww_grid.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"swin.ww_grid;\nshow(swin.ww_grid')","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Now the magic accessor allows users to access the same field using the more \"natural\" wavelength term","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"swin.wavelength_grid;\nshow(swin.wavelength_grid')","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"or even the Unicode symbol λ:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"swin.λ_grid;\nshow(swin.λ_grid')","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Note that swin.λ_grid or swin.wavelength_grid do not perform a calculation or conversion. For the spectral window type SpectralWindow, an overloaded getproperty function was dynamically created during startup such that getproperty(SpectralWindow, :λ) returns the ww_grid field, and similarly for wavenumber units.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Since types with some spectral dimension must also have a corresponding unit field, ww_unit, the getproperty function is able to check whether the requested spectral unit is appropriate. Trying to access swin.wavenumber_grid or swin.ν_grid will fail:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"swin.wavenumber_grid # or swin.ν","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Benchmarks have shown there is no significant performance drawback due to the use of the new getproperty functions.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When writing new functions that use objects of any types with a spectral unit, users can interrogate the ww_unit field to control the behavior of calculations. Inside RetrievalToolbox, this is done, for example, for the Doppler shift calculations, which use different expressions depending on whether they are performed in wavelength or wavenumber space.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"function something_new(swin::RE.SpectralWindow)\n\n    if swin.ww_unit isa Unitful.LengthUnit\n        # Do calculations in wavelength space\n    elseif swin.ww_unit isa Unitful.WavenumberUnit\n        # Do calculations in wavenumber space\n    end\n\nend","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When users write functions, they should be mindful of when they use .ww_grid compared to .wavelength_grid or .wavenumber_grid. For many calculations, it makes no difference whether the spectral unit is wavelength or wavenumber, and thus writing .ww is legible and reasonable. If some function only makes sense in one spectral unit, but not in the other, then .wavenumber_grid or .wavelength_grid can be used. Note that in this case, an error will be thrown if an object with the wrong spectral unit is passed into this function, and the spectral unit will be accessed via .wavenumber_grid or .wavelength_grid. This might be the desired behavior - calculations should throw an error if invoked in the wrong spectral unit space.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When users write top-level retrieval scripts for some specific scenario, it is usually most obvious to write the specific spectral unit, as that does not change and it also becomes clear that only that specific spectral unit is considered. I.e., a retrieval script that launches OCO-2 retrievals should access the spectral unit with .wavelength_grid.","category":"page"},{"location":"design/design/#Build-your-own-algorithm!","page":"Design","title":"Build your own algorithm!","text":"","category":"section"},{"location":"design/design/#Custom-forward-model","page":"Design","title":"Custom forward model","text":"","category":"section"},{"location":"design/design/#Lack-of-an-instrument-type","page":"Design","title":"Lack of an instrument type","text":"","category":"section"},{"location":"design/design/#Custom-ingestion-of-needed-inputs","page":"Design","title":"Custom ingestion of needed inputs","text":"","category":"section"},{"location":"design/design/#Extend-the-toolkit-with-your-own-types-and-functions","page":"Design","title":"Extend the toolkit with your own types and functions","text":"","category":"section"},{"location":"types/buffer_types/#Buffer-types","page":"Buffer Types","title":"Buffer types","text":"","category":"section"},{"location":"pitfalls/pitfalls/#Known-pitfalls-and-issues","page":"Pitfalls","title":"Known pitfalls & issues","text":"","category":"section"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"This section of the documentation deals with known pitfalls regarding the usage of the toolkit, as well as more structural issues. Due to the highly modular philosophy of this software, many critical portions of an algorithm implementation are up to the user and, by design, not part of the toolkit itself. Thus, it is easily possible to break some of the intended program flow.","category":"page"},{"location":"pitfalls/pitfalls/#Azimuthal-angles-and-convention-for-use-with-XRTM","page":"Pitfalls","title":"Azimuthal angles and convention for use with XRTM","text":"","category":"section"},{"location":"pitfalls/pitfalls/#Mutability-of-many-RetrievalToolbox-objects","page":"Pitfalls","title":"Mutability of many RetrievalToolbox objects","text":"","category":"section"},{"location":"pitfalls/pitfalls/#Angles-and-trigonometric-functions-with-Unitful.jl","page":"Pitfalls","title":"Angles and trigonometric functions with Unitful.jl","text":"","category":"section"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"In Julia, calling trigonometric functions is straightforward, with angles being naturally considered to be in units of radiants:","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"sin(pi/2)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"There are also trigonometric functions that ingest angles in degrees, which are conveniently named the same but append a d at the end, e.g. sin becomes sind, or cos becomes cosd. The behavior is as expected","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"sind(90.0)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"When using the Unitful.jl package, one can attach appropriate units to angle values. The library also provides an implementation of the common trigonometric functions such that the appropriate unit conversions take place internally:","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\n\nx = 90u\"°\"\nsin(x)\ncos(x)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Similarly, the cosd and sind functions as provided by Unitful.jl accept degree-valued quantities that provide the correct result. In the case of some degree-valued quantity, x, the result happens to the same:","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\n\nx = 55u\"°\"\nsin(x)\nsind(x)\n","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Looking closer into what functions are called, we observe that sin and sind provide the interface to the correct function when the argument is a degree-valued quantity. However if the argument is radians-valued, sind will not perform the appropriate conversion!","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\n\nx = 45u\"°\"\ny = (pi/4)u\"rad\"\n\ncode_lowered(sin, tuple(typeof(x)))\ncode_lowered(sind, tuple(typeof(x)))\ncode_lowered(sin, tuple(typeof(y)))\ncode_lowered(sind, tuple(typeof(y)))\n","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"The code block above shows that sind, when called with a radians-valued quantity will simply perform a deg2rad conversion and use the sin function on the argument. More importantly, no error will be thrown when such a computation is attempted!","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\n\ny = (pi/4)u\"rad\"\nz = y |> u\"°\"\n\n# This is not what we want!\nsind(y)\n# This is!\nsind(z)\n","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"warning: Warning\nTrigonometric functions meant for degree-valued arguments, such as sind or cosd do not perform automatic unit conversions, even if the argument is a Unitful quantity! Calculating cosd((pi/2)u\"rad\") will yield an unexpected answer!","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"tip: Tip\nIt is best-practice to clearly document which units certain angle variables must have, and then use the appropriate trigonometric functions! Always use e.g. cosd when degree-valued angles are expected, but use e.g. cos if a Unitful angle quantity is expected.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Further, users should be aware of implicit conversions when assigning angle-valued quantities to object fields. This is a particular danger with buffers, as those are instantiated and then modified in-place at some later point. The example below illustrates the issue.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Assume some mutable, user-defined type t that accepts some float as its only field. We then instantiate a new variable v with some arbitrary value.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\nmutable struct t{T <: AbstractFloat}\n    a::T\nend\n\nv = t(123.456)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"At some later point, we would like to change v.a. For the sake of this example, assume we want to give it the value of 15 degrees. Following code executes without raising an error.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"\nv.a = 15.0u\"°\"","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Yet, when we inspect the value v.a itself, we see that an implicit conversion has taken place which turned the 15° into equivalent radians. The conversion happened since angular units are dimensionless, or have dimension [1], so can always be turned into a Unitful.NoUnits quantity which then can be cast into a \"regular\" Julia number. Some function which might perform a calculation on some object of this type, therefore should not use the degree-versions of trigonometric functions.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"v.a\ndeg2rad(15.0)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"warning: Warning\nUnitful angle-valued quantities are prone to implicit conversions to radians!","category":"page"},{"location":"julia/dicts/#Working-with-Dictionaries","page":"Dictionaries","title":"Working with Dictionaries","text":"","category":"section"},{"location":"concepts/phasefunction/#Scattering-Phase-Function-and-its-Expansion","page":"Scattering Phasefunction","title":"Scattering Phase Function and its Expansion","text":"","category":"section"},{"location":"julia/units/#Working-with-Unitful.jl-units","page":"Units","title":"Working with Unitful.jl units","text":"","category":"section"},{"location":"julia/units/#Introduction","page":"Units","title":"Introduction","text":"","category":"section"},{"location":"julia/units/","page":"Units","title":"Units","text":"The retrieval toolkit currently uses Unitful.jl[Unitful] to attach physical units to various quantities that need them. This section here will present a short introduction to the package as well introduce helpful code snippets that should be used when working with RE. Some of these are currently used throughout the package to make sure that calculations are unit-aware.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Unitful.jl introduces new types which allows users to perform calculations that respect the units of quantities of those types. For example, adding various length-type quantities triggers automatic unit conversions (using Unitful.jl is assumed for all code examples).","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n\n5.2u\"m\" + 123.5u\"inch\" - 0.005u\"mi\"","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Performing e.g. an addition with quantities of incompatible units will raise an error.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n10.0u\"m\" + 5.0u\"kg\"","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In general, most types of numbers and arrays can be outfitted with a physical unit, and most basic computations with them will involve the automatic checks for compatible dimensions and, if needed, unit conversions.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n[1., 2., 3., 4.] * u\"Pa\" + [0.05, 0.06, 0.07, 0.08] * u\"Torr\"","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Note that in the example above, the resulting quantity is not in units of Pascal, but in kg m⁻¹ s⁻², since Unitful.jl will usually default to SI units once a conversion has taken place. This behavior can be controlled, however, more details are found in the Unitful.jl documentation.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"One can force unit conversion to any compatible unit via the uconvert function (note the broadcasting - uconvert does not dispatch on arrays or vectors).","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\nx = [1., 2., 3., 4.] * u\"Pa\" + [0.05, 0.06, 0.07, 0.08] * u\"Torr\"\nuconvert.(Ref(u\"Pa\"), x)","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In the example above, it is important to understand that the object x is a vector of pressure-type units. Julia allows for the mixing of types within a vector, so one can feasibly have a vector or array with mixed units. In this next example, we have three quantities of different units, although Julia will convert the quantities into Float64, even though the elements are initially typed as Float64, Float32 and Int64.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n[1.0u\"m\", 5.0f0u\"kg\", 20u\"s\"]","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In general, computations with Unitful-type arrays tend to be almost as fast as those with \"raw\" arrays of type Float32 or Float64. One of the exceptions is exponentiation with non-integer valued exponents, as shown below.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\nusing BenchmarkTools\n\nN = 16;\nA = rand(Float32, N, N);\nA_u = A * u\"Pa\";\n\n@benchmark A.^3.5 seconds=1\n@benchmark A_u.^3.5 seconds=1","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Various linear algebra operations can be performed with Unitful quantities, such as the inverse of a square matrix, and the units of the returned object will be correct.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n\nA = rand(5, 5) * u\"kg\";\ninv(A)","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"On the other hand, computing the QR-decomposition on such a matrix will fail.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\nusing LinearAlgebra\nA = rand(5, 5) * u\"kg\";\nqr(A)","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"warning: Warning\nMany functions, especially those that call lower-level routines (such as BLAS), might not be compatible with Unitful quantities, or arrays composed of them!","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"While the result of certain linear algebra operations using matrices with physical units might make sense intuitively, others might not be well-defined. Further, it depends highly on the actual implementation and it is difficult to know whether a certain piece of Julia code will execute for a vector or matrix that has Unitful units attached to them.","category":"page"},{"location":"julia/units/#Usage-within-RetrievalToolbox","page":"Units","title":"Usage within RetrievalToolbox","text":"","category":"section"},{"location":"julia/units/","page":"Units","title":"Units","text":"It is possible to use Unitful quantities directly in custom types and perform calculations using objects of those types. The convenience of this approach is clear: since every variable has units attached to them, an error will be raised immediately when an incompatible computation is performed. So if some part of a computation is accidentally mistyped and results in an operation that is not valid from a physical unit perspective, such as adding pressure and temperature, the code will not successfully execute. Further, if the computations themselves implicitly perform the required unit conversions, users do not need to write code that takes care of possible unit conversions. In addition to that, a flexible unit system allows users to choose their units of preference, e.g. state their pressures in \"hPa\" rather than \"Pa\".","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"There are currently two major drawbacks that were identified during the development of RetrievalToolbox when trying to use vectors and matrices of some Unitful type.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Some linear algebra operations were fundamentally incompatible with Unitful matrices\nSome operations (e.g. exponentiation, taking the logarithm) suffered from performance drops","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Regarding (1), most computations can be performed with Unitful vectors and matrices without having to adapt the code. Various linear algebra operations, however, as is necessary for the inversion, require matrices that by definition have mixed units. If Unitful is consistently used for all quantities, then the prior covariance matrix for an OE-type retrieval, for example, will have various units for the quantities that occur within the matrix. While the inversion equations obviously are consistent in terms of their physical units, some of the linear algebra operations (e.g. computing the inverse of a larger matrix might use decomposition techniques) will fail since those tend to be optimized for numerical efficiency and might contain incompatible sub-operations. This issue can be circumvented by casting a Unitful matrix into a regular \"numeric\" matrix, performing the needed calculations, and then re-attaching the units at a later stage.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"A similar solution can be used for (2) by identifying which operations suffer from performance issues and making sure that those will be executed for regular matrices and vectors, rather than involving the Unitful types.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"The current implementation of physical units in RetrievalToolbox uses a hybrid and more explicit approach. Every custom type with a field that should have a physical unit, also has a field that contains the physical unit. As an example, a GasAbsorber contains a volume mixing ratio profile vmr_levels. We want to give users the option to define a VMR profile in various units, such as ppb when working with methane, or ppm when working with carbon dioxide. So for the vmr_levels field, there is an accompanying field vmr_unit which carries the Unitful type that describes the physical unit.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"struct GasAbsorber{T} <: AbstractAtmosphereElement where T\n\n    gas_name::String\n    spectroscopy::AbstractSpectroscopy\n    vmr_levels::Vector{T}\n    vmr_unit::Unitful.DimensionlessUnits\n\nend","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Note that above, we can not just demand that the user instantiate the object with a Unitful type, but we can also make sure that the assigned unit makes sense for this particular object. Volume mixing ratios should be dimensionless (or dimension 1), and Unitful provides a type that represents all the explicit types. There are many other types that fall into the same category, we can use e.g. Unitful.LengthUnits if we want to force any type of length unit.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Of course now, users and code maintainers must use explicitly use the unit information and make sure that possible unit conversions are taken into account when they need to be. For dimensionless units, the situation is straightforward, since applying the NoUnits function will convert the dimensionless quantity into parts.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Users and code maintainers must ensure the appropriate use, and below we demonstrate the general idea with examples.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"For example one, we have two dimensionless quantities x and y. Both x and y are Float64 in this case, and their associated units are stored in separate variables x_u and y_u. If we have to compute a new quantity x + y, we must first make sure the units of each are considered.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n\nx = 1.234;\nx_u = u\"ppm\";\n\ny = 1500.0;\ny_u = u\"ppb\";\n\ny * y_u + x * x_u |> NoUnits","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In the next example, we consider two pressure values p1 and p2 whose units p1_u and p2_u are not necessarily the same. Let us assume that we must carry on the computation in units of p2_u. The function ustrip provided by Unitful is very helpful in this way. When called with a Unitful quantity alone, the unit will be simply stripped, and the numeric value is retained, e.g. ustrip(123.0u\"hPa\") returns 123.0. However, when we call ustrip with a leading argument, being a compatible unit, the quantity will first be converted to that unit. ustrip(u\"Pa\", 123.0u\"hPa\") will return 12300.0.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In the first variant of performing p1 + p2, we first construct Unitful quantities by multiplying each pressure value by its respective unit, p1 * p1_u and p2 * p2_u, and then perform the sum. The intermediate sum will be in SI pressure units, but then we apply the ustrip function to convert the sum into units of p2_u and strip the unit to obtain the numerical value only.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n#=\n    Version 1\n=#\np1 = 1100.0; p1_u = u\"hPa\";\np2 = 55.5; p2_u = u\"Pa\";\nresult = ustrip(p2_u, p1 * p1_u + p2 * p2_u)","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In the second variant demonstrated here we first construct p1 * p1_u to obtain a Unitful object, which yields 1100.0 hPa, and immediately convert it into units of p2_u (Pa) and stripping the unit, such that this new variable tmp becomes 110000.0. Now we have pressure p1 as a numerical value in units of Pa (implicit), and can simply add it to p2 to obtain the same result as above.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n#=\n    Version 2\n=#\np1 = 1100.0; p1_u = u\"hPa\";\np2 = 55.5; p2_u = u\"Pa\";\ntmp = ustrip(p2_u, p1 * p1_u);\nresult = p2 + tmp","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Throughout RetrievalToolbox both variants are applied.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"[Unitful]: https://github.com/PainterQubits/Unitful.jl","category":"page"},{"location":"functions/misc_functions/#Miscellaneous-functions","page":"Miscellaneous functions","title":"Miscellaneous functions","text":"","category":"section"},{"location":"functions/misc_functions/","page":"Miscellaneous functions","title":"Miscellaneous functions","text":"Functions here are usually general \"helper\" or \"utility\" type functions that a likely used throughout different parts of RetrievalToolbox.","category":"page"},{"location":"functions/misc_functions/#RetrievalToolbox.FWHM_to_sigma-Tuple{Number}","page":"Miscellaneous functions","title":"RetrievalToolbox.FWHM_to_sigma","text":"FWHM_to_sigma(FWHM::Number) -> Any\n\n\nCalculates the standard deviation of a Gaussian for a given full width at half the maximum value.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.H2O_VMR_to_specific_humidity-Tuple{Number}","page":"Miscellaneous functions","title":"RetrievalToolbox.H2O_VMR_to_specific_humidity","text":"H2O_VMR_to_specific_humidity(h2o::Number) -> Any\n\n\nCalculates specific humidity from H2O VMR\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.findany-Tuple{AbstractVector, Any}","page":"Miscellaneous functions","title":"RetrievalToolbox.findany","text":"findany(x::AbstractVector, a) -> Bool\n\n\nReturns true if a is found within x, does not allocate.\n\nExamples\n\njulia> findany([\"a\", \"b\", \"c\", \"d\"], \"b\")\ntrue\n\njulia> findany([1,2,3,4,5], 10)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.findanytype-Tuple{AbstractVector, Any}","page":"Miscellaneous functions","title":"RetrievalToolbox.findanytype","text":"findanytype(x::AbstractVector, T) -> Bool\n\n\nReturns true if any element within x is of type T, does not allocate.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.ingest!-Tuple{Any, Symbol, AbstractArray}","page":"Miscellaneous functions","title":"RetrievalToolbox.ingest!","text":"ingest!(obj, field::Symbol, val::AbstractArray)\n\n\nSets a RetrievalToolbox type field and applies the correct unit conversion. This is the specialized function to deal with array-type values. This should be mostlya allocation-free.\n\nDetails\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.ingest!-Tuple{Any, Symbol, Number}","page":"Miscellaneous functions","title":"RetrievalToolbox.ingest!","text":"ingest!(obj, field::Symbol, val::Number)\n\n\nSets a RetrievalToolbox type field and applies the correct unit conversion\n\nDetails\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.levels_to_layers!-Tuple{AbstractVector, AbstractVector}","page":"Miscellaneous functions","title":"RetrievalToolbox.levels_to_layers!","text":"levels_to_layers!(\n    layers::AbstractVector,\n    levels::AbstractVector;\n    logspace\n)\n\n\nFor a given level vector, calculate the mid-layer values and store into layers. This function assumes that the layer-value is evaluated at the center point between the two adjacent levels.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.levels_to_layers-Tuple{AbstractVector}","page":"Miscellaneous functions","title":"RetrievalToolbox.levels_to_layers","text":"levels_to_layers(levels::AbstractVector; logspace) -> Any\n\n\nFor a given level object, create a new vector that contains the mid-layer vector. This function assumes that the layer-value is evaluated at the center point between the two adjacent levels.\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.pwl_value_1d_axb!-NTuple{5, Any}","page":"Miscellaneous functions","title":"RetrievalToolbox.pwl_value_1d_axb!","text":"a * b\n\n\n\n\n\n","category":"method"},{"location":"functions/misc_functions/#RetrievalToolbox.specific_humidity_to_H2O_VMR-Tuple{Number}","page":"Miscellaneous functions","title":"RetrievalToolbox.specific_humidity_to_H2O_VMR","text":"specific_humidity_to_H2O_VMR(sh::Number) -> Any\n\n\nCalculates H2O VMR from specific humidity\n\n\n\n\n\n","category":"method"},{"location":"types/state_vector_types/#State-Vector-Types","page":"State Vector Types","title":"State Vector Types","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"Certain components of RetrievalToolbox require an AbstractStateVector that controls the computation of quantities relevant to a retrieval algorithm. For example, during the calculation of optical properties, the routine scans through the supplied AbstractStateVector to decide whether certain partial derivatives are needed.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"State vector types can be understood as custom structures that only contain the most necessary information about them as needed in an optimal estimation-type retrieval algorithm, and variables of these types are self-descriptive. State vector elements dictate the behavior of functions that are employed in forward models. For example, the apply_radiance_correction! function is implemented for appropriate state vector elements. Somewhere in the forward model, it will be appropraite to alter the forward model calculation, depending on the state vector.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"The code section below shows a simple example in which some radiance correction is applied to a state vector object state_vector. In this example, a loop runs through all state vector elements and the appropriate apply_radiance_correction! function is dispatched on the specific type of the state vector element object.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"# My forward model\n\n# [...]\n# Calculate radiances here\n# [...]\n\n# Apply radiance correction, depending on state vector\nfor sve in state_vector.state_vector_elements\n    RE.apply_radiance_correction!(buffer, sve)\nend\n\n# [...]\n","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"This way of writing a forward model makes use of Julia's multiple dispatch paradigm via which the most specific function will be called, if it is implemented. The strong benefit to users is that the forward model itself remains very legible, as no long conditional statements are needed to determine when to perform the required computation. The default implementation of the function in this example does nothing, so any state vector elements that should not induce any change in the forward model at this point, will act as expected.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"More fundamentally, any forward model must incorporate the state vector its calculations through updating the state upon which the forward model acts. Users must implement necessary functionality themselves.  Since RetrievalToolbox does not provide a forward model per se, but rather provides the many components that users can utilize to build one, there are many functions which require a state vector type, as listed further in State Vector Functions.","category":"page"},{"location":"types/state_vector_types/#Retrieval-State-Vector","page":"State Vector Types","title":"Retrieval State Vector","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"A RetrievalStateVector can be instantiated by passing a vector of  AbstractStateVectorElement variables.","category":"page"},{"location":"types/state_vector_types/#RetrievalToolbox.RetrievalStateVector","page":"State Vector Types","title":"RetrievalToolbox.RetrievalStateVector","text":"A type to hold a collection of state vector elements for use in a retrieval.\n\nstate_vector_elements::Vector{AbstractStateVectorElement}\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#State-Vector-Element-(SVE)-Types","page":"State Vector Types","title":"State Vector Element (SVE) Types","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"An AbstractStateVector consists of a list of state vector element (SVE) types, which are all subtypes of AbstractStateVectorElement. Every AbstractStateVectorElement type must be implemented as a mutable struct, due to the overall design of RE. Since instantiating new state vectors and state vector elements for each new retrieval scene would impact highly negatively on the overall performance, mutable structs are used. Once instantiated, users must make sure to reset each state vector element at the beginning of a new retrieval by setting the appropriate values and emptying out the iterations vector field with empty!(sve.iterations), with sve being the state vector element variable.","category":"page"},{"location":"types/state_vector_types/#Gas-scaling-factors","page":"State Vector Types","title":"Gas scaling factors","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"For ceratain retrieval applications, it is sufficient to scale the volume mixing ratio profile of some target gas, rather than having to retrieve the full shape. The GasLevelScalingFactorSVE allows to define a section of the volume mixing ratio profile (or the full profile from top to bottom), which is adjusted during the retrieval.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"If, for example, in a 10-level atmosphere set-up start_level and end_level are chosen to be (1, 5), then this SVE will only change the upper half of the gas VMR profile. To let this SVE scale the full profile, in this case the two values should be set to (1, 10), as the values are inclusive - inclusive meaning that the scale factor affects VMR profiles at levels 1,2,3,..,8,9,10. Multiple GasLevelScalingFactorSVE elements can appear in a state vector, each referencing a different portion of the atmosphere. As of now, there is no error catching mechanism, so users could define overlapping sections that will likely result in poor retrieval performance.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"Within the calculations of optical properties, there are checks in place to determine whether partial derivatives of the optical properties with respect to volume mixing ratios are required. If a GasLevelScalingFactorSVE is part of the state vector, the partial derivatives of optical depth with respect to volume mixing ratio is automatically  calculated.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"This type requires a unit without dimensions, such as Unitful.percent or Unitful.NoUnits.","category":"page"},{"location":"types/state_vector_types/#RetrievalToolbox.GasLevelScalingFactorSVE","page":"State Vector Types","title":"RetrievalToolbox.GasLevelScalingFactorSVE","text":"A type to represent a state vector element which scales a gas profile sub-column at the retrieval grid by its current value. start_level must be lower value (higher up in the atmosphere) than the end_level.\n\nstart_level::Int64: Start index of the sub-column (inclusive)\nend_level::Int64: Stop index of the sub-column (inclusive)\ngas::GasAbsorber: The gas object whose volume mixing ratio is scaled\nunit::Unitful.Units{U, NoDims} where U: Require dimensionless unit (e.g. Unitful.percent, or u\"1\")\nfirst_guess::Any: First guess value\nprior_value::Any: Prior value\nprior_covariance::Any: Prior covariance value\niterations::Vector: Vector to hold per-iteration values\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#Surface-pressure","page":"State Vector Types","title":"Surface pressure","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"The atmospheric model in RetrievalToolbox, the surface pressure is equal to the lowest retrieval pressure level. Retrieving surface pressure through a SurfacePressureSVE allows shifting that lowest level. As with, e.g. the GasLevelScalingFactorSVE, the optical property routines will automatically perform the necessary calculations of partial derivatives that are needed to obtain the appropriate Jacobian.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"Note that there is no default or automatic adjustment of the retrieval pressure level grid that takes into account a possible surface pressure retrieval.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"warning: Warning\nUsers must implement the adjustment of surface pressure into the retrieval grid themselves. A failure to do so will result in poor retrieval performance.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"This state vector element requires a unit that is compatible with pressure (e.g. Pascal) which does not need to be the same unit as that of the retrieval pressure level grid. The code internally handles the conversion. Users could, for example, user a retrieval grid in Pascal, but retrieve the surface pressure in units of Torr.","category":"page"},{"location":"types/state_vector_types/#RetrievalToolbox.SurfacePressureSVE","page":"State Vector Types","title":"RetrievalToolbox.SurfacePressureSVE","text":"State factor type for surface pressure retrieval\n\nunit::Unitful.Units{U, 𝐌 𝐋^-1 𝐓^-2} where U: Require pressure units (e.g. Pa, Torr, hPa, ..)\nfirst_guess::AbstractFloat\nprior_value::AbstractFloat\nprior_covariance::AbstractFloat\niterations::Vector{T} where T<:AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#Surface-albedo-polynomial","page":"State Vector Types","title":"Surface albedo polynomial","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"For a Lambertian surface model, in particular a LambertianPolynomialSurface, users can retrieve the polynomial coefficients. This state vector element has to be attached to a spectral window, since surfaces themselves are attached to a spectral window. Like all polynomial-related quantities, any state vector element must relate to a particular coefficient order. A convenience constructor exists which populates the unit field appropriately, given the coefficient order. One might call, for example","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"RE.SurfaceAlbedoPolynomial(\n    swin, # Spectral window\n    2, # Polynomial order\n    u\"µm\", # Associated unit\n    0.0, # First guess\n    0.0, # Prior value\n    0.0, # Prior covariance\n)","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"where the appropriate unit u\"µm^-2\" will be generated automatically, and the user must only supply some unit that is compatible with the spectral unit of the spectral window, i.e. a length unit for wavelengths, or a wavenumber unit for wavenumbers. An error will be thrown if units are incompatible.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"This state vector element creates a wavelength-dependent quantity and uses the reference wavelength given by the linked spectral window. When calculating the surface reflectivity via calculate_surface_reflectivity!, the specialized function calculate_Lambertian_surface_reflectivity! computes the per-wavelength albedo using the relative wavelength lambda - lambda_mathrmref or relative wavenumber nu - nu_mathrmref.","category":"page"},{"location":"types/state_vector_types/#RetrievalToolbox.SurfaceAlbedoPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.SurfaceAlbedoPolynomialSVE","text":"State vector type for Lambertian surface albedo polynomials\n\nswin::AbstractSpectralWindow: Spectral window to which this SVE is attached to\ncoefficient_order::Int64: Polynomial coefficient order (0-indexed, order 0 means constant)\nunit::Unitful.Units: Depending on the coefficient order \"o\", this unit should be L^{-o}\nfirst_guess::AbstractFloat: First guess value\nprior_value::AbstractFloat: Prior value\nprior_covariance::AbstractFloat: Prior covariance value\niterations::Vector{T1} where T1<:AbstractFloat: Vector to hold per-iteration values\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"In order to update the surface(s) given some state vector, a helper function exists which performs the in-place update within a RE.EarthScene object: RE.surfaces_statevector_update!.","category":"page"},{"location":"types/state_vector_types/#Dispersion-polynomial","page":"State Vector Types","title":"Dispersion polynomial","text":"","category":"section"},{"location":"types/state_vector_types/#RetrievalToolbox.DispersionPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.DispersionPolynomialSVE","text":"State factor type for dispersion polynomial coefficient retrieval\n\ndispersion::AbstractDispersion\ncoefficient_order::Int64\nunit::Union{Unitful.Units{U, 𝐋} where U, Unitful.Units{U, 𝐋^-1} where U}: Require unit of length or wavenumber\nfirst_guess::AbstractFloat\nprior_value::AbstractFloat\nprior_covariance::AbstractFloat\niterations::Vector{T} where T<:AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#Zero-level-offset-polynomial","page":"State Vector Types","title":"Zero level offset polynomial","text":"","category":"section"},{"location":"types/state_vector_types/#RetrievalToolbox.ZeroLevelOffsetPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.ZeroLevelOffsetPolynomialSVE","text":"State vector type for zero level offset polynomials\n\nswin::AbstractSpectralWindow: Spectral window to which this SVE is attached to\ncoefficient_order::Int64: Polynomial coefficient order (0-indexed, order 0 means constant)\nww_unit::Unitful.Units: Depending on the coefficient order \"o\", this unit should be L^{-o}\nunit::Union{Real, Unitful.Units}: Full unit\nfirst_guess::AbstractFloat: First guess value\nprior_value::AbstractFloat: Prior value\nprior_covariance::AbstractFloat: Prior covariance value\niterations::Vector{T1} where T1<:AbstractFloat: Vector to hold per-iteration values\n\n\n\n\n\n","category":"type"},{"location":"functions/atmosphere_functions/#Atmosphere-functions","page":"Atmosphere Functions","title":"Atmosphere functions","text":"","category":"section"},{"location":"functions/atmosphere_functions/","page":"Atmosphere Functions","title":"Atmosphere Functions","text":"Functions below are designed to operate on atmosphere object, and for the time being mostly on EarthAtmosphere ones.","category":"page"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.JPL_gravity-Tuple{Number, Number}","page":"Atmosphere Functions","title":"RetrievalToolbox.JPL_gravity","text":"JPL_gravity(\n    latitude::Number,\n    altitude::Number;\n    earth_equatorial_radius\n) -> Any\n\n\nCalculates local gravity given some latitude and altitude. Note that the altitude can be be a simple number, in which the input is assumed to be in meters. If you supply a Unitful quantity, appropriate unit conversions are done. In either case, this function will return a Unitful quantity that will reduce to acceleration [m s⁻²].\n\nDetails\n\nThis code was taken from MS3 / the CSU simulator suite, with heritage related to the OCO-1 retrieval algorithm written at JPL. See https://github.com/nasa/RtRetrievalFramework at ./lib/implementation/altitude_hydrostatic.cc.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_rollback!-Tuple{AbstractAtmosphereElement, AbstractStateVectorElement}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_rollback!","text":"atmosphere_element_statevector_rollback!(\n    atm_element::AbstractAtmosphereElement,\n    sve::AbstractStateVectorElement\n) -> Any\n\n\nDefault behavior: do nothing\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_rollback!-Tuple{GasAbsorber, GasLevelScalingFactorSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_rollback!","text":"atmosphere_element_statevector_rollback!(\n    atm_element::GasAbsorber,\n    sve::GasLevelScalingFactorSVE\n) -> Any\n\n\nRolls back the GasAbsorber volume mixing ratio profile to its first-guess state as defined in sve.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Tuple{AbstractAtmosphereElement, AbstractStateVectorElement}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_element::AbstractAtmosphereElement,\n    sve::AbstractStateVectorElement\n) -> Any\n\n\nDefault function to update the atmosphere element atm_element according to the current value of the state vector element sve. This does nothing!\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Tuple{GasAbsorber, GasLevelScalingFactorSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_element::GasAbsorber,\n    sve::GasLevelScalingFactorSVE\n) -> Any\n\n\nUpdates the GasAbsorber volume mixing ratio profile according to sve.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Tuple{GasAbsorber, GasVMRProfileSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_element::GasAbsorber,\n    sve::GasVMRProfileSVE\n) -> Any\n\n\nUpdates atmospheric element atm_element if a GasVMRProfileSVE is present.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_element_statevector_update!-Union{Tuple{T}, Tuple{Vector{T}, AbstractStateVector}} where T<:AbstractAtmosphereElement","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_element_statevector_update!","text":"atmosphere_element_statevector_update!(\n    atm_elements::Array{T<:AbstractAtmosphereElement, 1},\n    SV::AbstractStateVector\n)\n\n\nFunction to update all atmosphere elements in the vector atm_elements according to the current value of all state vector elements in the state vector SV.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.atmosphere_statevector_update!-Tuple{AbstractAtmosphere, TemperatureOffsetSVE}","page":"Atmosphere Functions","title":"RetrievalToolbox.atmosphere_statevector_update!","text":"Updates the atmosphere `atm` for a `TemperatureOffsetSVE` state vector element.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_altitude_and_gravity!-Tuple{EarthScene}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_altitude_and_gravity!","text":"calculate_altitude_and_gravity!(scene::EarthScene)\n\n\nCalculates altitude and gravity for an EarthScene, assuming that all other needed quantities have been inserted accordingly, namely: pressure levels, temperatures layers, specific humidity layers and location. Note! Layer-based values are calculated in this function call and overwrite existing values!\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_altitude_and_gravity_levels!-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Number, EarthLocation}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_altitude_and_gravity_levels!","text":"calculate_altitude_and_gravity_levels!(\n    z_levels::AbstractVector,\n    g_levels::AbstractVector,\n    p_levels::AbstractVector,\n    T_layers::AbstractVector,\n    SH_layers::AbstractVector,\n    p_surf::Number,\n    location::EarthLocation\n)\n\n\nCalculates altitude and gravity levels for Earth-type atmospheres, in-place. For now, this function over-writes altitude_levels and gravity_levels in units of m and m/s^2 respectively!\n\nDetails\n\nGiven some atmospheric inputs (p, T, q) and the scene latitude and altitude, this function calculates the altitude and gravity profiles (on levels) corresponding to the pressure levels. These outputs should then be used to construct atmosphere objects (EarthAtmosphere).\n\nAt this point, p_levels must be in [Pa], T_layers in [K], SH_layers in [1], and the location.altitude in [m]. Alternatively, Unitful arrays with units can be used.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_gravity_from_z!-Tuple{EarthAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_gravity_from_z!","text":"calculate_gravity_from_z!(atm::EarthAtmosphere; g)\n\n\nCalculates local gravity based on altitude levels. The optional argument g can be supplied if users want a latitude=dependent surface-level gravity. Otherwise the standard gravity g0 (9.80655 ms⁻²) is used. Note that g must be in compatible units of acceleration.\n\nDetails\n\nThe gravity g(z) at altitude z is calculated as\n\ng(z) = g cdot (fracR_eR_e + z)^2\n\nwhere R_e is the (mean) Earth radius and g is the assumed gravity at the surface.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_layers!-Tuple{EarthAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_layers!","text":"calculate_layers!(atm::EarthAtmosphere)\n\n\nIn-place calculation of mid-layer values for all relevant profiles in an EarthAtmosphere object (p, p MET, q, T, z, g).\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.calculate_xgas-Tuple{AbstractAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.calculate_xgas","text":"calculate_xgas(atm::AbstractAtmosphere; gas_name) -> Dict\n\n\nCalculates the XGAS from an AbstractAtmosphere atm.\n\nThe column-averaged dry-air mole fraction is calculated according to O'Dell et al., 10.5194/amt-5-99-2012. Note that the returned quantity comes with the same unit as defined in the GasAbsorber object, which defines the VMR levels of that particular gas.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_ACOS_pressure_grid-Tuple{Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_ACOS_pressure_grid","text":"create_ACOS_pressure_grid(\n    psurf::Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}\n) -> Vector\n\n\nCreates the ACOS-type pressure grid on 20 levels\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_UoL_pressure_grid-Tuple{Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_UoL_pressure_grid","text":"create_UoL_pressure_grid(\n    p_surf::Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U},\n    p_tropo::Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U};\n    N_total\n) -> Vector\n\n\nCreates the 'classic' University of Leicester-type pressure grid\n\nDetails\n\nA pressure grid is generated with fixed 5 stratospheric levels. The sixth level is halfway between tropopause pressure and level 5, and the seventh level is the tropopause pressure itself. Finally, the remaining levels are evenly spaced between the tropopause and the surface pressure. The total number of pressure levels must be greater than 8 (default: 20). If the tropopause pressure is larger than 8000 Pa (i.e. higher in the atmosphere), levels 6 and 7 are then set to predefined values and the tropopause is then considered to be level 7.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_empty_EarthAtmosphere-Tuple{Integer, Integer, Type{<:Real}}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_empty_EarthAtmosphere","text":"create_empty_EarthAtmosphere(\n    Nlev::Integer,\n    Nlev_met::Integer,\n    T::Type{<:Real};\n    pressure_unit,\n    met_pressure_unit,\n    temperature_unit,\n    specific_humidity_unit,\n    altitude_unit,\n    gravity_unit,\n    U,\n    U\n) -> EarthAtmosphere\n\n\nCreates an empty EarthAtmosphere object with the specified number of retrieval grid levels, meteorological grid levels, array type T as well as units for the profiles. This function takes optional arguments to define the units for the various profiles.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_example_atmosphere-Tuple{String, Integer}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_example_atmosphere","text":"create_example_atmosphere(\n    name::String,\n    Nlev::Integer;\n    T,\n    surface_pressure,\n    altitude,\n    is_example\n) -> EarthAtmosphere{Float64}\n\n\nCreates an EarthAtmosphere object based on some representative atmospheres that were extracted from NASA GMAO's MERRA2 reanalysis and Sourish Basu's CO2/CH4. Must provide the name of the example atmosphere name as well as the intended number of pressure levels for the retrieval grid, Nlev, to be filled out be the user later.\n\nOptional arguments are surface_pressure or altitude (must choose one or none, never both) to adjust the model atmosphere accordingly.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_example_gas_profile-Tuple{String, String, AbstractSpectroscopy, Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}}}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_example_gas_profile","text":"create_example_gas_profile(\n    name::String,\n    gas_name::String,\n    spec::AbstractSpectroscopy,\n    plevels::Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-1 𝐓^-2, U}} where {L, S}} where {T, U}};\n    is_example\n) -> GasAbsorber\n\n\nCreates a gas profile from an example atmosphere, and attaches it to a supplied spectroscopy object spec. Pressure levels must also be given, which have to match the retrieval pressure levels.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_level_from_midlayer-Tuple{Any}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_level_from_midlayer","text":"create_level_from_midlayer(q) -> Any\n\n\nCreates a level-based profile from one defined on middle-of-the-layer. Assumes that the mid-layer value is well-approximated by half the value of the layer-boundary values.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.create_pressure_weights-Tuple{AbstractAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.create_pressure_weights","text":"Calculates the pressure weights according to O'Dell et al. in 10.5194/amt-5-99-2012. Note that this assumes that the gas concentrations vary linearly with pressure, as implemented in the function calculate_gas_optical_depth_profiles.\n\ncreate_pressure_weights(\n    atm::AbstractAtmosphere;\n    N_sub\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.get_gas_from_name-Tuple{EarthAtmosphere, String}","page":"Atmosphere Functions","title":"RetrievalToolbox.get_gas_from_name","text":"get_gas_from_name(\n    atm::EarthAtmosphere,\n    name::String\n) -> Union{Nothing, AbstractAtmosphereElement}\n\n\nGiven an atmosphere object, this function returns a reference to the gas object whose name is the same as some string name.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.list_example_atmospheres-Tuple{}","page":"Atmosphere Functions","title":"RetrievalToolbox.list_example_atmospheres","text":"list_example_atmospheres() -> Vector{String}\n\n\nLists all available example atmospheres that can be loaded with create_example_atmosphere.\n\n\n\n\n\n","category":"method"},{"location":"functions/atmosphere_functions/#RetrievalToolbox.update_specific_humidity_from_H2O!-Tuple{EarthAtmosphere}","page":"Atmosphere Functions","title":"RetrievalToolbox.update_specific_humidity_from_H2O!","text":"update_specific_humidity_from_H2O!(\n    atm::EarthAtmosphere\n) -> Bool\n\n\nUpdates the specific humidity profile of the atmosphere atm, if an H2O profile is available as an atmospheric element. Does not update gravity and altitude profiles!\n\n\n\n\n\n","category":"method"},{"location":"","page":"Main","title":"Main","text":"RetrievalToolbox is a software library written in pure Julia to facilitate building trace gas retrieval algorithms and related applications.","category":"page"},{"location":"julia/develop/#How-to-develop-or-extend-RetrievalToolbox","page":"Develop","title":"How to develop or extend RetrievalToolbox","text":"","category":"section"}]
}
