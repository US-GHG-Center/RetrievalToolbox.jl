var documenterSearchIndex = {"docs":
[{"location":"concepts/fundamentals/#Fundamentals","page":"Fundamentals","title":"Fundamentals","text":"","category":"section"},{"location":"concepts/fundamentals/#How-to-build-a-retrieval-algorithm","page":"Fundamentals","title":"How to build a retrieval algorithm","text":"","category":"section"},{"location":"concepts/fundamentals/#Utilizing-Buffers","page":"Fundamentals","title":"Utilizing Buffers","text":"","category":"section"},{"location":"concepts/fundamentals/#Mutability-of-Objects","page":"Fundamentals","title":"Mutability of Objects","text":"","category":"section"},{"location":"concepts/radiance/#Working-with-radiance-types","page":"Radiance","title":"Working with radiance types","text":"","category":"section"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"The way RetrievalToolbox handles radiances is different, when compared to other objects such as","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"There are, at the moment, two radiance types that users can utilize to store calculated or measured radiance:","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"struct ScalarRadiance{T<:AbstractFloat} <: Radiance\n\n    I::Vector{T}\n\nend","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"and","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"struct VectorRadiance{T<:AbstractFloat} <: Radiance\n\n    I::Vector{T}\n    Q::Vector{T}\n    U::Vector{T}\n\nend","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"Depending on the situation, users can work with ScalarRadiance when polarization does not need to be accounted for, or use the VectorRadiance type if polarization is needed. Note that as opposed to many other types, these radiance containers do not have a unit field, but that might change in future versions.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"The main idea is to use whichever type is most natural for the specific application. While it would have been possible to only use a single radiance type which considers all components of the Stokes vector, it would require users to pay attention to Stokes components Q and U without ever truly needing them.","category":"page"},{"location":"concepts/radiance/#Basic-examples","page":"Radiance","title":"Basic examples","text":"","category":"section"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"For a very basic example, let us first generate some scalar radiance object using the internal constructor (not included in the above type definitions).","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"using RetrievalToolbox # hide\nconst RE = RetrievalToolbox # hide\nT = Float64;\nN = 4;\ns = RE.ScalarRadiance(T, N)","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"s is now our radiance object, which only has one field, namely I, representing the intensity for some number of spectral indices.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"Similarly, we can create a vector radiance that represents the first three components of the Stokes vector:","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"v = RE.VectorRadiance(T, N)","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"Functions that manipulate radiance can easily access the Stokes components inside either s or v via the explicit dot syntax.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"s.I[:] .= 0.1;\nv.I[:] .= 0.2;\nv.Q[:] .= -0.3;\nv.U[:] .= 0.03;","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"As with many types of RetrievalToolbox, the underlying fields are simple vectors, such that highly performant operations can be done with them. For now, RetrievalToolbox makes use of LoopVectorization.jl, which speeds up certain looped computations dramatically, and we can easily use e.g. the @turbo macro to wrap such loops. Below example shows a simple in-place calculation involving both s and v in a single loop body.","category":"page"},{"location":"concepts/radiance/","page":"Radiance","title":"Radiance","text":"using LoopVectorization\n\n@turbo for i in eachindex(s.I)\n    s.I[i] += v.I[i]\n    v.U[i] /= 2\n    v.Q[i] /= 2\nend\ns\nv","category":"page"},{"location":"concepts/radiance/#Using-StokesIterator","page":"Radiance","title":"Using StokesIterator","text":"","category":"section"},{"location":"concepts/core_concepts/#Core-Algorithm-Concepts","page":"Core Concepts","title":"Core Algorithm Concepts","text":"","category":"section"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"note: Note\nWithin the RetrievalToolbox algorithm tools, an attempt is made to keep notation consistent as well as stick to more modern terminology. This approach occasionally overrides more antiquated terms, so various sections in the documentation will emphasize when a possible clash is expected.","category":"page"},{"location":"concepts/core_concepts/#Instrument-Spectral-Response-Function-(formerly-ILS)","page":"Core Concepts","title":"Instrument Spectral Response Function (formerly ILS)","text":"","category":"section"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"OCO ATBD","category":"page"},{"location":"concepts/core_concepts/#Pixels,-Spectral-Samples-and-Dispersion","page":"Core Concepts","title":"Pixels, Spectral Samples and Dispersion","text":"","category":"section"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"The distinction between pixels, samples and what dispersion describes occasionally causes confusion due to a lack of consistent terminology in publications or other various documents.","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"A pixel is considered to be a discrete unit on an instrument detector of any type (where appropriate). Some instruments aggregate pixels during the read-out process such that the data received does not truly reflect the physical detector elements. Other instruments do read out the detector on a native pixel level, however some form of processing is performed afterwards and the resulting data, as ingested by retrieval algorithms, can no longer considered to be per-pixel.","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"Retrieval algorithms, in general, act on calibrated, geo-located radiance data, often denoted as Level-1b (L1B, L1b). For hyperspectral data, there usually is at least one spectral dimension of that data such that when the data is extracted along that dimension, one obtains what is considered a spectrum. One spectrum thus has a discrete number of elements along its spectral axis and the spectral axis consists of spectral samples. Those spectral samples do not have to be identical with the underlying detector pixels. For most instruments, they are not. Even for instruments in which the detector pixels map 1:1 into spectral samples, it is a good choice to stay consistent in the terminology and refer to an element of a spectrum as spectral sample.","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"For a single spectrum I that is extracted from calibrated, geo-located radiance data, the spectral sample information can be written explicitly as I_s, with s being some index of its spectral dimension. I_s is naturally a discrete quantity with s being a discrete index itself. Compare this to a theoretical description of radiance, which in general is a continuous function of wavelength or wavenumber tildeI(lambda) or tildeI(nu). In order to allow for a comparison between measured quantity I_s and a model radiance, one must know which wavelength or wavenumber corresponds to a spectral sample at index s.","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"The relationship between spectral sample (index) and wavelength or wavenumber is usually called dispersion. An alternative term for dispersion is wavelength solution. It is some general function d which maps a spectral sample index to either wavelength or wavenumber, whichever is appropriate for the specific instrument: d(s) = lambda_s or d(s) = nu_s. When d is known, it is straightforward to evaluate some continuous function tildeI at the correct wavelength or wavenumber in order to compare it to a measured value: I_s sim tildeIleft( d(s) right).","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"The function d is generally smooth and tends to be expressed as a polynomial which maps spectral sample to wavelength or wavenumber in the following way:","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"    lambda_s = sum_i=0^N c_i cdot s^i ","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"or","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"    nu_s = sum_i=0^N c_i cdot s^i","category":"page"},{"location":"concepts/core_concepts/","page":"Core Concepts","title":"Core Concepts","text":"The polynomial coefficients c are usually either available in the published measurement data, in accompanying documents, or in rare cases, have to be derived.","category":"page"},{"location":"functions/state_vector_functions/#State-Vector-Functions","page":"State Vector Functions","title":"State Vector Functions","text":"","category":"section"},{"location":"design/design/#Toolkit-design-philosophy","page":"Design","title":"Toolkit design philosophy","text":"","category":"section"},{"location":"design/design/#Namespace","page":"Design","title":"Namespace","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"The RetrievalToolbox module exports many functions, types and variables - some of those might share names with functions from other modules or your own user code. While not strictly necessary, we generally recommend to load the module and then declare an alias to then call the module functions through it.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"using RetrievalToolbox\nconst RE = RetrievalToolbox\n\nRE.some_function()\n\n# this, however, works too\nsome_function()","category":"page"},{"location":"design/design/#Reliance-on-Julia-types","page":"Design","title":"Reliance on Julia types","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"One of Julia's most prominent features is the flexibility that comes with its rich type system. While not object-oriented in the sense that C++ is, objects, their relationship to functions, and how they act on specific objects is a major design component of Julia and thus RetrievalToolbox.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"RetrievalToolbox defines a number of abstract types and then lots of composite types, which are akin to struct types in C. They usually sit below abstract types in the type hierarchy and represent some granular concept that is useful for trace gas retrievals.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"For example, the GaussAerosol type belongs to the AbstractAerosolType which itself belongs to AbstractAtmosphereElement, and describes some aerosol whose vertical distribution in the model atmosphere is described by a Gaussian. The full type hierarchy here is GaussAerosol ⊂ AbstractAerosolType ⊂ AbstractAtmosphereElement. When users create a model atmosphere, they must add some AbstractAtmosphereElement to the list of atmosphere elements. At that stage, we do not care what specific object that might be, as long as it satisfies the requirement that it has to be a type that is a subtype of AbstractAtmosphereElement.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Now how does Julia's type system and the multiple dispatch paradigm help us here. First, it allows for some convenience. We can use some list of atmospheric elements that we want represented in our model atmosphere: aerosols and Rayleigh scattering. Those two are quite different in practical terms, even though they might act in similar ways on our various calculations. So if we have some list of AbstractAtmosphereElement objects","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"atm_list = [aerosol1, aerosol2, RayleighScattering()]","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"we would ideally want to perform some action with each of those elements, such as calculating their contribution to the optical depth profiles of our model atmosphere. Some naïve way of doing that would be to iterate through each element and perform the appropriate action:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"for atm in atm_list\n    if is_an_aerosol(atm)\n        tau = calculate_gauss_aerosol_tau(atm)\n    end\n\n    if is_Rayleigh_scattering(atm)\n        tau = calculate_Rayleigh_tau(atm)\n    end\n\n    # .. do something with tau\nend","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"This is easily done with Julia, but makes this top-level iteration not very elegant. One can imagine that if we implement several aerosol distribution types, this loop will grow since we want to call the dedicated function to perform the wanted operation. The preferred way in Julia is making use of multiple dispatch: we decide on a name for a function that shall perform the equivalent task for different types. Let us call this function calculate_tau:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"for atm in atm_list\n    tau = calculate_tau(atm)\n    # .. do something with tau\nend","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"and as long as there is a function calculate_tau which implements the calculate for the requested type, above code will execute and keep this top-level loop nice and tidy.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"While the above example allows for some convenience, the strength of multiple dispatch also lies in how users can expand code without having to change code deep within a module they use. For example, let us imagine a new aerosol type that a user wants to integrate in their retrieval application: MyAerosolType. A new list of atmosphere elements would be created, like so","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"my_new_aerosol = MyAerosolType()\natm_list = [aerosol1, aerosol2, RayleighScattering(), my_new_aerosol()]","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Now in this imagined scenario, the user can now create their own calculate_tau function, which would implement the specific routine that computes the optical depth profiles for their new aerosol type:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"function calculate_tau(a::MyAerosolType)\n    # Do many calculations here...\n    # ...\nend","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When done correctly, the new function will be invoked when the loop above runs (for atm in atm_list ...)  since the Julia compiler will now look for a calculate_tau function that can act on an object of type MyAerosolType.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"To summarize: RetrievalToolbox makes extensive use of Julia's type system such that many functions in the module do not act on primitive types (like numbers or strings), but on custom composite types.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"info: Info\nThe Julia type system allows for flexibility in creating program code that looks the same for a variety of object types. Further, users can more easily extend existing code with their own types without necessarily having to change the underlying routines, but by providing their own user code.","category":"page"},{"location":"design/design/#Buffers-for-performance","page":"Design","title":"Buffers for performance","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"Julia is a garbage-collected language (more detailed info here), meaning that users do not have explicit control over how and when objects are de-allocated from memory. When users write functions that allocate (by creating vectors and arrays, for example), the memory is not immediately freed when the function is completed. The garbage collector (GC) is triggered at some point when the memory usage reaches some level. The GC then traces through the objects in memory and removes those that are no longer used.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"The big advantage of GC-based languages is of course that manual memory management is no longer needed, and users do not have to keep track of correct allocation and de-allocation of objects, and memory safety issues are also less common. The major downside is that without manual memory management, users could (un)willingly write code that very inefficiently allocates a lot of memory. When those allocations happen in certain places (loops mostly), memory will fill up quickly and trigger GC sweeps very often. The paradigm within Julia is usually: allocate arrays and vectors beforehand, and perform calculations on these pre-allocated objects.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Early versions of RetrievalToolbox did not make use of much pre-allocation, and most calls to functions would create new objects. This has proven to be not a feasible solution. While convenient for top-level scripting, the many allocations needed made it impossible to run faster retrievals where the forward model run was much less than a second (e.g. physics-based SIF retrievals or other non-scattering applications).","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Thus, we make use of pre-allocated objects, which we call buffers here.","category":"page"},{"location":"design/design/#Order-of-instantiation-in-a-retrieval-algorithm","page":"Design","title":"Order of instantiation in a retrieval algorithm","text":"","category":"section"},{"location":"design/design/#Executing-the-forward-model-will-mutate-some-objects","page":"Design","title":"Executing the forward model will mutate some objects","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"Kinda bad for e.g. gas scale factors that mean factors of some initial atmospheric state.","category":"page"},{"location":"design/design/#Wrapper-functions-and-specific-dispatch","page":"Design","title":"Wrapper functions and specific dispatch","text":"","category":"section"},{"location":"design/design/#Considering-quantities-with-physical-units","page":"Design","title":"Considering quantities with physical units","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"Explain types and dedicated type fields for units. Pay attention to supplying quantities with the right units!","category":"page"},{"location":"design/design/#Wavelengths-and-wavenumbers","page":"Design","title":"Wavelengths and wavenumbers","text":"","category":"section"},{"location":"design/design/","page":"Design","title":"Design","text":"RetrievalToolbox supports two fundamental spectral unit types: wavelength and wavenumber. Users might want to build an algorithm pipeline that is specific to some instrument, which natively produces spectra in either wavelength or wavenumber units. In order to make the native spectral unit be visible as such, RetrievalToolbox provides dynamic accessors which allow users to reference the spectral unit of objects using their natural wording or symbol.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Rather than writing duplicate types and functions, RetrievalToolbox employs magic accessor methods. Any quantity that represents a spectral unit, is typed ww or, for example, ww_unit or ww_reference. The two-letter combination ww is thus reserved in the RetrievalToolbox codebase, and no type fields should contain this combination of letters.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"The ww should be considered a placeholder, which represents either a wavelength- or a wavenumber-related quantity. Any type that contains a field or quantity ww must also contain a field named ww_unit. Other fields are optional.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When the RetrievalToolbox module is imported, all types inside the RetrievalToolbox namespace are scanned for type fields that contain the substring ww. For each type that contains such a field, a new accessor function is dynamically created, which allows users to access the spectral type fields with the appropriate symbol. Illustrative examples follow.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Creating a spectral window object from 1.49 µm through 1.55 µm with 10 nm spacing could, for example, look like this (with loaded Unitful):","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"using RetrievalToolbox # hide\nconst RE = RetrievalToolbox # hide\nusing Unitful # hide\n\nswin = RE.SpectralWindow(\n    \"test\",\n    1.49, # Lower limit\n    1.55, # Upper limit\n    collect(1.48:0.01:1.56), # Create the grid with spacing\n    Unitful.µm, # Designate microns as unit of choice\n    1.50 # Set some reference wavelength\n    )","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"As can be seen in the type definition, the spectral grid can be accessed via swin.ww_grid.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"swin.ww_grid;\nshow(swin.ww_grid')","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Now the magic accessor allows users to access the same field using the more \"natural\" wavelength term","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"swin.wavelength_grid;\nshow(swin.wavelength_grid')","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"or even the Unicode symbol λ:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"swin.λ_grid;\nshow(swin.λ_grid')","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Note that swin.λ_grid or swin.wavelength_grid do not perform a calculation or conversion. For the spectral window type SpectralWindow, an overloaded getproperty function was dynamically created during startup such that getproperty(SpectralWindow, :λ) returns the ww_grid field, and similarly for wavenumber units.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Since types with some spectral dimension must also have a corresponding unit field, ww_unit, the getproperty function is able to check whether the requested spectral unit is appropriate. Trying to access swin.wavenumber_grid or swin.ν_grid will fail:","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"swin.wavenumber_grid # or swin.ν","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"Benchmarks have shown there is no significant performance drawback due to the use of the new getproperty functions.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When writing new functions that use objects of any types with a spectral unit, users can interrogate the ww_unit field to control the behavior of calculations. Inside RetrievalToolbox, this is done, for example, for the Doppler shift calculations, which use different expressions depending on whether they are performed in wavelength or wavenumber space.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"function something_new(swin::RE.SpectralWindow)\n\n    if swin.ww_unit isa Unitful.LengthUnit\n        # Do calculations in wavelength space\n    elseif swin.ww_unit isa Unitful.WavenumberUnit\n        # Do calculations in wavenumber space\n    end\n\nend","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When users write functions, they should be mindful of when they use .ww_grid compared to .wavelength_grid or .wavenumber_grid. For many calculations, it makes no difference whether the spectral unit is wavelength or wavenumber, and thus writing .ww is legible and reasonable. If some function only makes sense in one spectral unit, but not in the other, then .wavenumber_grid or .wavelength_grid can be used. Note that in this case, an error will be thrown if an object with the wrong spectral unit is passed into this function, and the spectral unit will be accessed via .wavenumber_grid or .wavelength_grid. This might be the desired behavior - calculations should throw an error if invoked in the wrong spectral unit space.","category":"page"},{"location":"design/design/","page":"Design","title":"Design","text":"When users write top-level retrieval scripts for some specific scenario, it is usually most obvious to write the specific spectral unit, as that does not change and it also becomes clear that only that specific spectral unit is considered. I.e., a retrieval script that launches OCO-2 retrievals should access the spectral unit with .wavelength_grid.","category":"page"},{"location":"design/design/#Build-your-own-algorithm!","page":"Design","title":"Build your own algorithm!","text":"","category":"section"},{"location":"design/design/#Custom-forward-model","page":"Design","title":"Custom forward model","text":"","category":"section"},{"location":"design/design/#Lack-of-an-instrument-type","page":"Design","title":"Lack of an instrument type","text":"","category":"section"},{"location":"design/design/#Custom-ingestion-of-needed-inputs","page":"Design","title":"Custom ingestion of needed inputs","text":"","category":"section"},{"location":"design/design/#Extend-the-toolkit-with-your-own-types-and-functions","page":"Design","title":"Extend the toolkit with your own types and functions","text":"","category":"section"},{"location":"types/buffer_types/#Buffer-types","page":"Buffer Types","title":"Buffer types","text":"","category":"section"},{"location":"pitfalls/pitfalls/#Known-pitfalls-and-issues","page":"Pitfalls","title":"Known pitfalls & issues","text":"","category":"section"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"This section of the documentation deals with known pitfalls regarding the usage of the toolkit, as well as more structural issues. Due to the highly modular philosophy of this software, many critical portions of an algorithm implementation are up to the user and, by design, not part of the toolkit itself. Thus, it is easily possible to break some of the intended program flow.","category":"page"},{"location":"pitfalls/pitfalls/#Azimuthal-angles-and-convention-for-use-with-XRTM","page":"Pitfalls","title":"Azimuthal angles and convention for use with XRTM","text":"","category":"section"},{"location":"pitfalls/pitfalls/#Mutability-of-many-RetrievalToolbox-objects","page":"Pitfalls","title":"Mutability of many RetrievalToolbox objects","text":"","category":"section"},{"location":"pitfalls/pitfalls/#Angles-and-trigonometric-functions-with-Unitful.jl","page":"Pitfalls","title":"Angles and trigonometric functions with Unitful.jl","text":"","category":"section"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"In Julia, calling trigonometric functions is straightforward, with angles being naturally considered to be in units of radiants:","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"sin(pi/2)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"There are also trigonometric functions that ingest angles in degrees, which are conveniently named the same but append a d at the end, e.g. sin becomes sind, or cos becomes cosd. The behavior is as expected","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"sind(90.0)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"When using the Unitful.jl package, one can attach appropriate units to angle values. The library also provides an implementation of the common trigonometric functions such that the appropriate unit conversions take place internally:","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\n\nx = 90u\"°\"\nsin(x)\ncos(x)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Similarly, the cosd and sind functions as provided by Unitful.jl accept degree-valued quantities that provide the correct result. In the case of some degree-valued quantity, x, the result happens to the same:","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\n\nx = 55u\"°\"\nsin(x)\nsind(x)\n","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Looking closer into what functions are called, we observe that sin and sind provide the interface to the correct function when the argument is a degree-valued quantity. However if the argument is radians-valued, sind will not perform the appropriate conversion!","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\n\nx = 45u\"°\"\ny = (pi/4)u\"rad\"\n\ncode_lowered(sin, tuple(typeof(x)))\ncode_lowered(sind, tuple(typeof(x)))\ncode_lowered(sin, tuple(typeof(y)))\ncode_lowered(sind, tuple(typeof(y)))\n","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"The code block above shows that sind, when called with a radians-valued quantity will simply perform a deg2rad conversion and use the sin function on the argument. More importantly, no error will be thrown when such a computation is attempted!","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\n\ny = (pi/4)u\"rad\"\nz = y |> u\"°\"\n\n# This is not what we want!\nsind(y)\n# This is!\nsind(z)\n","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"warning: Warning\nTrigonometric functions meant for degree-valued arguments, such as sind or cosd do not perform automatic unit conversions, even if the argument is a Unitful quantity! Calculating cosd((pi/2)u\"rad\") will yield an unexpected answer!","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"tip: Tip\nIt is best-practice to clearly document which units certain angle variables must have, and then use the appropriate trigonometric functions! Always use e.g. cosd when degree-valued angles are expected, but use e.g. cos if a Unitful angle quantity is expected.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Further, users should be aware of implicit conversions when assigning angle-valued quantities to object fields. This is a particular danger with buffers, as those are instantiated and then modified in-place at some later point. The example below illustrates the issue.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Assume some mutable, user-defined type t that accepts some float as its only field. We then instantiate a new variable v with some arbitrary value.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"using Unitful # hide\nmutable struct t{T <: AbstractFloat}\n    a::T\nend\n\nv = t(123.456)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"At some later point, we would like to change v.a. For the sake of this example, assume we want to give it the value of 15 degrees. Following code executes without raising an error.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"\nv.a = 15.0u\"°\"","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"Yet, when we inspect the value v.a itself, we see that an implicit conversion has taken place which turned the 15° into equivalent radians. The conversion happened since angular units are dimensionless, or have dimension [1], so can always be turned into a Unitful.NoUnits quantity which then can be cast into a \"regular\" Julia number. Some function which might perform a calculation on some object of this type, therefore should not use the degree-versions of trigonometric functions.","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"v.a\ndeg2rad(15.0)","category":"page"},{"location":"pitfalls/pitfalls/","page":"Pitfalls","title":"Pitfalls","text":"warning: Warning\nUnitful angle-valued quantities are prone to implicit conversions to radians!","category":"page"},{"location":"julia/dicts/#Working-with-Dictionaries","page":"Dictionaries","title":"Working with Dictionaries","text":"","category":"section"},{"location":"concepts/phasefunction/#Scattering-Phase-Function-and-its-Expansion","page":"Scattering Phasefunction","title":"Scattering Phase Function and its Expansion","text":"","category":"section"},{"location":"julia/units/#Working-with-Unitful.jl-units","page":"Units","title":"Working with Unitful.jl units","text":"","category":"section"},{"location":"julia/units/#Introduction","page":"Units","title":"Introduction","text":"","category":"section"},{"location":"julia/units/","page":"Units","title":"Units","text":"The retrieval toolkit currently uses Unitful.jl[Unitful] to attach physical units to various quantities that need them. This section here will present a short introduction to the package as well introduce helpful code snippets that should be used when working with RE. Some of these are currently used throughout the package to make sure that calculations are unit-aware.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Unitful.jl introduces new types which allows users to perform calculations that respect the units of quantities of those types. For example, adding various length-type quantities triggers automatic unit conversions (using Unitful.jl is assumed for all code examples).","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n\n5.2u\"m\" + 123.5u\"inch\" - 0.005u\"mi\"","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Performing e.g. an addition with quantities of incompatible units will raise an error.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n10.0u\"m\" + 5.0u\"kg\"","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In general, most types of numbers and arrays can be outfitted with a physical unit, and most basic computations with them will involve the automatic checks for compatible dimensions and, if needed, unit conversions.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n[1., 2., 3., 4.] * u\"Pa\" + [0.05, 0.06, 0.07, 0.08] * u\"Torr\"","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Note that in the example above, the resulting quantity is not in units of Pascal, but in kg m⁻¹ s⁻², since Unitful.jl will usually default to SI units once a conversion has taken place. This behavior can be controlled, however, more details are found in the Unitful.jl documentation.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"One can force unit conversion to any compatible unit via the uconvert function (note the broadcasting - uconvert does not dispatch on arrays or vectors).","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\nx = [1., 2., 3., 4.] * u\"Pa\" + [0.05, 0.06, 0.07, 0.08] * u\"Torr\"\nuconvert.(Ref(u\"Pa\"), x)","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In the example above, it is important to understand that the object x is a vector of pressure-type units. Julia allows for the mixing of types within a vector, so one can feasibly have a vector or array with mixed units. In this next example, we have three quantities of different units, although Julia will convert the quantities into Float64, even though the elements are initially typed as Float64, Float32 and Int64.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n[1.0u\"m\", 5.0f0u\"kg\", 20u\"s\"]","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In general, computations with Unitful-type arrays tend to be almost as fast as those with \"raw\" arrays of type Float32 or Float64. One of the exceptions is exponentiation with non-integer valued exponents, as shown below.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\nusing BenchmarkTools\n\nN = 16;\nA = rand(Float32, N, N);\nA_u = A * u\"Pa\";\n\n@benchmark A.^3.5 seconds=1\n@benchmark A_u.^3.5 seconds=1","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Various linear algebra operations can be performed with Unitful quantities, such as the inverse of a square matrix, and the units of the returned object will be correct.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n\nA = rand(5, 5) * u\"kg\";\ninv(A)","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"On the other hand, computing the QR-decomposition on such a matrix will fail.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\nusing LinearAlgebra\nA = rand(5, 5) * u\"kg\";\nqr(A)","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"warning: Warning\nMany functions, especially those that call lower-level routines (such as BLAS), might not be compatible with Unitful quantities, or arrays composed of them!","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"While the result of certain linear algebra operations using matrices with physical units might make sense intuitively, others might not be well-defined. Further, it depends highly on the actual implementation and it is difficult to know whether a certain piece of Julia code will execute for a vector or matrix that has Unitful units attached to them.","category":"page"},{"location":"julia/units/#Usage-within-RetrievalToolbox","page":"Units","title":"Usage within RetrievalToolbox","text":"","category":"section"},{"location":"julia/units/","page":"Units","title":"Units","text":"It is possible to use Unitful quantities directly in custom types and perform calculations using objects of those types. The convenience of this approach is clear: since every variable has units attached to them, an error will be raised immediately when an incompatible computation is performed. So if some part of a computation is accidentally mistyped and results in an operation that is not valid from a physical unit perspective, such as adding pressure and temperature, the code will not successfully execute. Further, if the computations themselves implicitly perform the required unit conversions, users do not need to write code that takes care of possible unit conversions. In addition to that, a flexible unit system allows users to choose their units of preference, e.g. state their pressures in \"hPa\" rather than \"Pa\".","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"There are currently two major drawbacks that were identified during the development of RetrievalToolbox when trying to use vectors and matrices of some Unitful type.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Some linear algebra operations were fundamentally incompatible with Unitful matrices\nSome operations (e.g. exponentiation, taking the logarithm) suffered from performance drops","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Regarding (1), most computations can be performed with Unitful vectors and matrices without having to adapt the code. Various linear algebra operations, however, as is necessary for the inversion, require matrices that by definition have mixed units. If Unitful is consistently used for all quantities, then the prior covariance matrix for an OE-type retrieval, for example, will have various units for the quantities that occur within the matrix. While the inversion equations obviously are consistent in terms of their physical units, some of the linear algebra operations (e.g. computing the inverse of a larger matrix might use decomposition techniques) will fail since those tend to be optimized for numerical efficiency and might contain incompatible sub-operations. This issue can be circumvented by casting a Unitful matrix into a regular \"numeric\" matrix, performing the needed calculations, and then re-attaching the units at a later stage.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"A similar solution can be used for (2) by identifying which operations suffer from performance issues and making sure that those will be executed for regular matrices and vectors, rather than involving the Unitful types.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"The current implementation of physical units in RetrievalToolbox uses a hybrid and more explicit approach. Every custom type with a field that should have a physical unit, also has a field that contains the physical unit. As an example, a GasAbsorber contains a volume mixing ratio profile vmr_levels. We want to give users the option to define a VMR profile in various units, such as ppb when working with methane, or ppm when working with carbon dioxide. So for the vmr_levels field, there is an accompanying field vmr_unit which carries the Unitful type that describes the physical unit.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"struct GasAbsorber{T} <: AbstractAtmosphereElement where T\n\n    gas_name::String\n    spectroscopy::AbstractSpectroscopy\n    vmr_levels::Vector{T}\n    vmr_unit::Unitful.DimensionlessUnits\n\nend","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Note that above, we can not just demand that the user instantiate the object with a Unitful type, but we can also make sure that the assigned unit makes sense for this particular object. Volume mixing ratios should be dimensionless (or dimension 1), and Unitful provides a type that represents all the explicit types. There are many other types that fall into the same category, we can use e.g. Unitful.LengthUnits if we want to force any type of length unit.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Of course now, users and code maintainers must use explicitly use the unit information and make sure that possible unit conversions are taken into account when they need to be. For dimensionless units, the situation is straightforward, since applying the NoUnits function will convert the dimensionless quantity into parts.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Users and code maintainers must ensure the appropriate use, and below we demonstrate the general idea with examples.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"For example one, we have two dimensionless quantities x and y. Both x and y are Float64 in this case, and their associated units are stored in separate variables x_u and y_u. If we have to compute a new quantity x + y, we must first make sure the units of each are considered.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n\nx = 1.234;\nx_u = u\"ppm\";\n\ny = 1500.0;\ny_u = u\"ppb\";\n\ny * y_u + x * x_u |> NoUnits","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In the next example, we consider two pressure values p1 and p2 whose units p1_u and p2_u are not necessarily the same. Let us assume that we must carry on the computation in units of p2_u. The function ustrip provided by Unitful is very helpful in this way. When called with a Unitful quantity alone, the unit will be simply stripped, and the numeric value is retained, e.g. ustrip(123.0u\"hPa\") returns 123.0. However, when we call ustrip with a leading argument, being a compatible unit, the quantity will first be converted to that unit. ustrip(u\"Pa\", 123.0u\"hPa\") will return 12300.0.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In the first variant of performing p1 + p2, we first construct Unitful quantities by multiplying each pressure value by its respective unit, p1 * p1_u and p2 * p2_u, and then perform the sum. The intermediate sum will be in SI pressure units, but then we apply the ustrip function to convert the sum into units of p2_u and strip the unit to obtain the numerical value only.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n#=\n    Version 1\n=#\np1 = 1100.0; p1_u = u\"hPa\";\np2 = 55.5; p2_u = u\"Pa\";\nresult = ustrip(p2_u, p1 * p1_u + p2 * p2_u)","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"In the second variant demonstrated here we first construct p1 * p1_u to obtain a Unitful object, which yields 1100.0 hPa, and immediately convert it into units of p2_u (Pa) and stripping the unit, such that this new variable tmp becomes 110000.0. Now we have pressure p1 as a numerical value in units of Pa (implicit), and can simply add it to p2 to obtain the same result as above.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"using Unitful # hide\n#=\n    Version 2\n=#\np1 = 1100.0; p1_u = u\"hPa\";\np2 = 55.5; p2_u = u\"Pa\";\ntmp = ustrip(p2_u, p1 * p1_u);\nresult = p2 + tmp","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"Throughout RetrievalToolbox both variants are applied.","category":"page"},{"location":"julia/units/","page":"Units","title":"Units","text":"[Unitful]: https://github.com/PainterQubits/Unitful.jl","category":"page"},{"location":"types/state_vector_types/#State-Vector-Types","page":"State Vector Types","title":"State Vector Types","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"Certain components of RetrievalToolbox require an AbstractStateVector that controls the computation of quantities relevant to a retrieval algorithm. For example, during the calculation of optical properties, the routine scans through the supplied AbstractStateVector to decide whether certain partial derivatives are needed.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"State vector types can be understood as custom structures that only contain the most necessary information about them as needed in an optimal estimation-type retrieval algorithm, and variables of these types are self-descriptive. State vector elements dictate the behavior of functions that are employed in forward models. For example, the apply_radiance_correction! function is implemented for appropriate state vector elements. Somewhere in the forward model, it will be appropraite to alter the forward model calculation, depending on the state vector.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"The code section below shows a simple example in which some radiance correction is applied to a state vector object state_vector. In this example, a loop runs through all state vector elements and the appropriate apply_radiance_correction! function is dispatched on the specific type of the state vector element object.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"# My forward model\n\n# [...]\n# Calculate radiances here\n# [...]\n\n# Apply radiance correction, depending on state vector\nfor sve in state_vector.state_vector_elements\n    RE.apply_radiance_correction!(buffer, sve)\nend\n\n# [...]\n","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"This way of writing a forward model makes use of Julia's multiple dispatch paradigm via which the most specific function will be called, if it is implemented. The strong benefit to users is that the forward model itself remains very legible, as no long conditional statements are needed to determine when to perform the required computation. The default implementation of the function in this example does nothing, so any state vector elements that should not induce any change in the forward model at this point, will act as expected.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"More fundamentally, any forward model must incorporate the state vector its calculations through updating the state upon which the forward model acts. Users must implement necessary functionality themselves.  Since RetrievalToolbox does not provide a forward model per se, but rather provides the many components that users can utilize to build one, there are many functions which require a state vector type, as listed further in State Vector Functions.","category":"page"},{"location":"types/state_vector_types/#Retrieval-State-Vector","page":"State Vector Types","title":"Retrieval State Vector","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"A RetrievalStateVector can be instantiated by passing a vector of  AbstractStateVectorElement variables.","category":"page"},{"location":"types/state_vector_types/#RetrievalToolbox.RetrievalStateVector","page":"State Vector Types","title":"RetrievalToolbox.RetrievalStateVector","text":"A type to hold a collection of state vector elements for use in a retrieval.\n\nstate_vector_elements::Vector{AbstractStateVectorElement}\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#State-Vector-Element-(SVE)-Types","page":"State Vector Types","title":"State Vector Element (SVE) Types","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"An AbstractStateVector consists of a list of state vector element (SVE) types, which are all subtypes of AbstractStateVectorElement. Every AbstractStateVectorElement type must be implemented as a mutable struct, due to the overall design of RE. Since instantiating new state vectors and state vector elements for each new retrieval scene would impact highly negatively on the overall performance, mutable structs are used. Once instantiated, users must make sure to reset each state vector element at the beginning of a new retrieval by setting the appropriate values and emptying out the iterations vector field with empty!(sve.iterations), with sve being the state vector element variable.","category":"page"},{"location":"types/state_vector_types/#Gas-scaling-factors","page":"State Vector Types","title":"Gas scaling factors","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"For ceratain retrieval applications, it is sufficient to scale the volume mixing ratio profile of some target gas, rather than having to retrieve the full shape. The GasLevelScalingFactorSVE allows to define a section of the volume mixing ratio profile (or the full profile from top to bottom), which is adjusted during the retrieval.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"If, for example, in a 10-level atmosphere set-up start_level and end_level are chosen to be (1, 5), then this SVE will only change the upper half of the gas VMR profile. To let this SVE scale the full profile, in this case the two values should be set to (1, 10), as the values are inclusive - inclusive meaning that the scale factor affects VMR profiles at levels 1,2,3,..,8,9,10. Multiple GasLevelScalingFactorSVE elements can appear in a state vector, each referencing a different portion of the atmosphere. As of now, there is no error catching mechanism, so users could define overlapping sections that will likely result in poor retrieval performance.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"Within the calculations of optical properties, there are checks in place to determine whether partial derivatives of the optical properties with respect to volume mixing ratios are required. If a GasLevelScalingFactorSVE is part of the state vector, the partial derivatives of optical depth with respect to volume mixing ratio is automatically  calculated.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"This type requires a unit without dimensions, such as Unitful.percent or Unitful.NoUnits.","category":"page"},{"location":"types/state_vector_types/#RetrievalToolbox.GasLevelScalingFactorSVE","page":"State Vector Types","title":"RetrievalToolbox.GasLevelScalingFactorSVE","text":"A type to represent a state vector element which scales a gas profile sub-column at the retrieval grid by its current value. start_level must be lower value (higher up in the atmosphere) than the end_level.\n\nstart_level::Int64: Start index of the sub-column (inclusive)\nend_level::Int64: Stop index of the sub-column (inclusive)\ngas::GasAbsorber: The gas object whose volume mixing ratio is scaled\nunit::Unitful.Units{U, NoDims} where U: Require dimensionless unit (e.g. Unitful.percent, or u\"1\")\nfirst_guess::Any: First guess value\nprior_value::Any: Prior value\nprior_covariance::Any: Prior covariance value\niterations::Vector: Vector to hold per-iteration values\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#Surface-pressure","page":"State Vector Types","title":"Surface pressure","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"The atmospheric model in RetrievalToolbox, the surface pressure is equal to the lowest retrieval pressure level. Retrieving surface pressure through a SurfacePressureSVE allows shifting that lowest level. As with, e.g. the GasLevelScalingFactorSVE, the optical property routines will automatically perform the necessary calculations of partial derivatives that are needed to obtain the appropriate Jacobian.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"Note that there is no default or automatic adjustment of the retrieval pressure level grid that takes into account a possible surface pressure retrieval.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"warning: Warning\nUsers must implement the adjustment of surface pressure into the retrieval grid themselves. A failure to do so will result in poor retrieval performance.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"This state vector element requires a unit that is compatible with pressure (e.g. Pascal) which does not need to be the same unit as that of the retrieval pressure level grid. The code internally handles the conversion. Users could, for example, user a retrieval grid in Pascal, but retrieve the surface pressure in units of Torr.","category":"page"},{"location":"types/state_vector_types/#RetrievalToolbox.SurfacePressureSVE","page":"State Vector Types","title":"RetrievalToolbox.SurfacePressureSVE","text":"State factor type for surface pressure retrieval\n\nunit::Unitful.Units{U, 𝐌 𝐋^-1 𝐓^-2} where U: Require pressure units (e.g. Pa, Torr, hPa, ..)\nfirst_guess::AbstractFloat\nprior_value::AbstractFloat\nprior_covariance::AbstractFloat\niterations::Vector{T} where T<:AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#Surface-albedo-polynomial","page":"State Vector Types","title":"Surface albedo polynomial","text":"","category":"section"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"For a Lambertian surface model, in particular a LambertianPolynomialSurface, users can retrieve the polynomial coefficients. This state vector element has to be attached to a spectral window, since surfaces themselves are attached to a spectral window. Like all polynomial-related quantities, any state vector element must relate to a particular coefficient order. A convenience constructor exists which populates the unit field appropriately, given the coefficient order. One might call, for example","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"RE.SurfaceAlbedoPolynomial(\n    swin, # Spectral window\n    2, # Polynomial order\n    u\"µm\", # Associated unit\n    0.0, # First guess\n    0.0, # Prior value\n    0.0, # Prior covariance\n)","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"where the appropriate unit u\"µm^-2\" will be generated automatically, and the user must only supply some unit that is compatible with the spectral unit of the spectral window, i.e. a length unit for wavelengths, or a wavenumber unit for wavenumbers. An error will be thrown if units are incompatible.","category":"page"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"This state vector element creates a wavelength-dependent quantity and uses the reference wavelength given by the linked spectral window. When calculating the surface reflectivity via calculate_surface_reflectivity!, the specialized function calculate_Lambertian_surface_reflectivity! computes the per-wavelength albedo using the relative wavelength lambda - lambda_mathrmref or relative wavenumber nu - nu_mathrmref.","category":"page"},{"location":"types/state_vector_types/#RetrievalToolbox.SurfaceAlbedoPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.SurfaceAlbedoPolynomialSVE","text":"State vector type for Lambertian surface albedo polynomials\n\nswin::AbstractSpectralWindow: Spectral window to which this SVE is attached to\ncoefficient_order::Int64: Polynomial coefficient order (0-indexed, order 0 means constant)\nunit::Unitful.Units: Depending on the coefficient order \"o\", this unit should be L^{-o}\nfirst_guess::AbstractFloat: First guess value\nprior_value::AbstractFloat: Prior value\nprior_covariance::AbstractFloat: Prior covariance value\niterations::Vector{T1} where T1<:AbstractFloat: Vector to hold per-iteration values\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/","page":"State Vector Types","title":"State Vector Types","text":"In order to update the surface(s) given some state vector, a helper function exists which performs the in-place update within a RE.EarthScene object: RE.surfaces_statevector_update!.","category":"page"},{"location":"types/state_vector_types/#Dispersion-polynomial","page":"State Vector Types","title":"Dispersion polynomial","text":"","category":"section"},{"location":"types/state_vector_types/#RetrievalToolbox.DispersionPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.DispersionPolynomialSVE","text":"State factor type for dispersion polynomial coefficient retrieval\n\ndispersion::AbstractDispersion\ncoefficient_order::Int64\nunit::Union{Unitful.Units{U, 𝐋} where U, Unitful.Units{U, 𝐋^-1} where U}: Require unit of length or wavenumber\nfirst_guess::AbstractFloat\nprior_value::AbstractFloat\nprior_covariance::AbstractFloat\niterations::Vector{T} where T<:AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"types/state_vector_types/#Zero-level-offset-polynomial","page":"State Vector Types","title":"Zero level offset polynomial","text":"","category":"section"},{"location":"types/state_vector_types/#RetrievalToolbox.ZeroLevelOffsetPolynomialSVE","page":"State Vector Types","title":"RetrievalToolbox.ZeroLevelOffsetPolynomialSVE","text":"State vector type for zero level offset polynomials\n\nswin::AbstractSpectralWindow: Spectral window to which this SVE is attached to\ncoefficient_order::Int64: Polynomial coefficient order (0-indexed, order 0 means constant)\nww_unit::Unitful.Units: Depending on the coefficient order \"o\", this unit should be L^{-o}\nunit::Union{Real, Unitful.Units}: Full unit\nfirst_guess::AbstractFloat: First guess value\nprior_value::AbstractFloat: Prior value\nprior_covariance::AbstractFloat: Prior covariance value\niterations::Vector{T1} where T1<:AbstractFloat: Vector to hold per-iteration values\n\n\n\n\n\n","category":"type"},{"location":"","page":"Main","title":"Main","text":"RetrievalToolbox is a software library written in pure Julia to facilitate building trace gas retrieval algorithms and related applications.","category":"page"}]
}
