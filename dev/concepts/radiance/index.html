<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Radiance · RetrievalToolbox.jl</title><meta name="title" content="Radiance · RetrievalToolbox.jl"/><meta property="og:title" content="Radiance · RetrievalToolbox.jl"/><meta property="twitter:title" content="Radiance · RetrievalToolbox.jl"/><meta name="description" content="Documentation for RetrievalToolbox.jl."/><meta property="og:description" content="Documentation for RetrievalToolbox.jl."/><meta property="twitter:description" content="Documentation for RetrievalToolbox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RetrievalToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Main</a></li><li><a class="tocitem" href="../../design/design/">Design</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../core_concepts/">Core Concepts</a></li><li class="is-active"><a class="tocitem" href>Radiance</a><ul class="internal"><li><a class="tocitem" href="#Basic-examples"><span>Basic examples</span></a></li></ul></li><li><a class="tocitem" href="../phasefunction/">Scattering Phasefunction</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/state_vector_functions/">State Vector Functions</a></li><li><a class="tocitem" href="../../functions/atmosphere_functions/">Atmosphere Functions</a></li></ul></li><li><span class="tocitem">Types</span><ul><li><a class="tocitem" href="../../types/atmosphere_types/">Atmosphere Types</a></li><li><a class="tocitem" href="../../types/buffer_types/">Buffer Types</a></li><li><a class="tocitem" href="../../types/state_vector_types/">State Vector Types</a></li></ul></li><li><span class="tocitem">Working with Julia</span><ul><li><a class="tocitem" href="../../julia/develop/">Develop</a></li><li><a class="tocitem" href="../../julia/dicts/">Dictionaries</a></li><li><a class="tocitem" href="../../julia/units/">Units</a></li></ul></li><li><span class="tocitem">Pitfalls</span><ul><li><a class="tocitem" href="../../pitfalls/pitfalls/">Pitfalls</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Concepts</a></li><li class="is-active"><a href>Radiance</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Radiance</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Working-with-radiance-types"><a class="docs-heading-anchor" href="#Working-with-radiance-types">Working with radiance types</a><a id="Working-with-radiance-types-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-radiance-types" title="Permalink"></a></h1><p>There are, at the moment, two radiance types that users can utilize to store calculated or measured radiance: <code>ScalarRadiance</code> and <code>VectorRadiance</code>. Both very similar to generic arrays, in fact they inherit many of the properties and functions from Julia&#39;s arrays.</p><p>Depending on the situation, users can work with <code>ScalarRadiance</code> when polarization does not need to be accounted for, or use the <code>VectorRadiance</code> type if polarization is needed. Note that as opposed to many other types, these radiance containers do not have a unit field, but that might change in future versions.</p><p>The main idea is to use whichever type is most natural for the specific application. While it would have been possible to only use a single radiance type which considers all components of the Stokes vector, it would require users to pay attention to Stokes components <em>Q</em> and <em>U</em> without ever truly needing them.</p><p>Both <code>ScalarRadiance</code> and <code>VectorRadiance</code> have only one field, named <code>S</code> which itself is the underlying array of some type <code>T</code> to store the radiance. For <code>ScalarRadiance</code>, <code>S</code> is a vector (intensity <em>I</em> only), and <code>VectorRadiance</code>, <code>S</code> is a 3-column array representing the <em>I</em>, <em>Q</em> and <em>U</em> components. Both radiance types possess appropriate accessor functions so users can use the more &quot;natural&quot; I, Q, U notation to access the Stokes components in addition to simply using the type field <code>.S</code>.</p><h2 id="Basic-examples"><a class="docs-heading-anchor" href="#Basic-examples">Basic examples</a><a id="Basic-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-examples" title="Permalink"></a></h2><p>For a very basic example, let us first generate some scalar radiance object using the internal constructor.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = Float64;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; N = 4;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = RE.ScalarRadiance(T, N)</code><code class="nohighlight hljs ansi" style="display:block;">4-element ScalarRadiance{Float64, Vector{Float64}}:
 0.0
 0.0
 0.0
 0.0</code></pre><p><code>s</code> is now our radiance object, which only has one field, namely <code>S</code>, representing the intensity for some number of spectral indices.</p><p>Similarly, we can create a vector radiance that represents the first three components of the Stokes vector:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = RE.VectorRadiance(T, N)</code><code class="nohighlight hljs ansi" style="display:block;">4×3 VectorRadiance{Float64, Matrix{Float64}}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>Functions that manipulate radiance can easily access the Stokes components inside either <code>s</code> or <code>v</code> via the explicit dot syntax.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s.I[:] .= 0.1;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v.I[:] .= 0.2;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v.Q[:] .= -0.3;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v.U[:] .= 0.03;</code></pre><p>The main reason why the underlying object <code>.S</code> is an Array/Vector-type for both is to facilitate highly performant operations. For now, RetrievalToolbox makes use of <code>LoopVectorization.jl</code>, which speeds up certain looped computations dramatically, and we can easily use e.g. the <code>@turbo</code> macro to wrap such loops. Having both radiance types look similar under the hood allows users to write fast functions that are agnostic to the type of radiance, and thus work for either. Yet, it is still possible to dispatch on a particular radiance type, so that specific calculations can be done according to whether some radiance object is a <code>ScalarRadiance</code> or a <code>VectorRadiance</code></p><p>For example, let&#39;s write a function that simply doubles all components of a radiance object:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LoopVectorization</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: Package LoopVectorization not found in current path.
- Run `import Pkg; Pkg.add(&quot;LoopVectorization&quot;)` to install the LoopVectorization package.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function double_rad!(r::Radiance)
           @turbo for i in axes(r, 1) # Loop over spectral points
               for j in axes(r, 2) # Loop over components (if applicable)
                   r.S[i,j] *= 2
               end
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: LoadError: UndefVarError: `@turbo` not defined in `Main`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name may be made accessible by importing LoopVectorization in the current active module Main
in expression starting at REPL[2]:2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; double_rad!(s)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `double_rad!` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(s)</code><code class="nohighlight hljs ansi" style="display:block;">[0.1, 0.1, 0.1, 0.1]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; double_rad!(v)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `double_rad!` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(v)</code><code class="nohighlight hljs ansi" style="display:block;">[0.2 -0.3 0.03; 0.2 -0.3 0.03; 0.2 -0.3 0.03; 0.2 -0.3 0.03]</code></pre><p>Note the following: first, we make sure that this function is only to be used on radiance types, so we use the <code>Radiance</code> type (which is simply a union between <code>ScalarRadiance</code> and <code>VectorRadiance</code>) to restrict the function argument <code>r</code>. Then, we write a @turbo-accelerated loop that stretches over two dimensions of r. Even for the one-dimensional scalar radiance <code>s</code>, a second dimension is accessible as long as that second dimension is accessed by the index <code>[1]</code>, trying to access another index will lead to a <code>BoundsError</code>. Lastly we do not simply write <code>r[i,j] *= 2</code>, but explicitly state the underlying array object <code>r.S</code> and write <code>r.S[i,j] *= 2</code>. While both versions would work in this case, the <code>@turbo</code> macro would not be able to produce accelerated code if we omit the <code>.S</code>.</p><div class="admonition is-info" id="Note-f59421664d6844f7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f59421664d6844f7" title="Permalink"></a></header><div class="admonition-body"><p>When writing code to perform operations on or with some radiance object <code>r</code>, best performance is achieved when explicitly using the underlying array object <code>r.S</code>.</p></div></div><p>The ability to write a two-dimensional loop body even for the one-dimensional scalar radiance is crucial and allows users to write radiance type-agnostic code. Mixing two radiance objects of different radiance type is also easy to do, but requires some more checks on the possible types. Note that <strong>as a conscious design decision, there are currently no arithmetic operations defined on radiance objects of different types</strong>, so users will have to explicitly write those operations. While one can perform e.g. additions on two radiance objects of <strong>the same type</strong>, operations on different types will generally fail.</p><p>For example, the following works without issues</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s + s</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.2
 0.2
 0.2
 0.2</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v - 2*v</code><code class="nohighlight hljs ansi" style="display:block;">4×3 Matrix{Float64}:
 -0.2  0.3  -0.03
 -0.2  0.3  -0.03
 -0.2  0.3  -0.03
 -0.2  0.3  -0.03</code></pre><p>This next example, however, will fail since the shapes are incompatible:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(size(s))</code><code class="nohighlight hljs ansi" style="display:block;">(4,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(size(v))</code><code class="nohighlight hljs ansi" style="display:block;">(4, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s + v</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: DimensionMismatch: a has size (4, 3), mismatch at dim 2</code></pre><p>When it so happens that two or more radiance objects have to be used in mathematical operations, a few simple checks can be done to make sure that compatible operations are performed.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; new_rad = VectorRadiance(T, N); # T,N from above..</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; r1 = s; r2 = v; # or can use r1 = v; r2 = s;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @views new_rad[:,1] = r1[:,1] + r2[:,1]; # Add intensity component (both have them)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; if r1 isa VectorRadiance
       @views new_rad[:,2:end] += r1[:,2:end]
       end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; if r2 isa VectorRadiance
       @views new_rad[:,2:end] += r2[:,2:end]
       end</code><code class="nohighlight hljs ansi" style="display:block;">4×2 Matrix{Float64}:
 -0.3  0.03
 -0.3  0.03
 -0.3  0.03
 -0.3  0.03</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; new_rad</code><code class="nohighlight hljs ansi" style="display:block;">4×3 VectorRadiance{Float64, Matrix{Float64}}:
 0.3  -0.3  0.03
 0.3  -0.3  0.03
 0.3  -0.3  0.03
 0.3  -0.3  0.03</code></pre><p>In general, the expectation is that users tend to know which radiance objects are vector radiances, and which ones are scalar radiances, so it should generally be possible to write explicit and performant code when e.g. scalar solar (ir)radiances are multiplied with top-of-atmosphere vector radiances. For rare cases where the type is not known, type checks like above can be used to make sure the operations will succeed regardless of the type.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../core_concepts/">« Core Concepts</a><a class="docs-footer-nextpage" href="../phasefunction/">Scattering Phasefunction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 29 September 2025 19:38">Monday 29 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
