<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design · RetrievalToolbox.jl</title><meta name="title" content="Design · RetrievalToolbox.jl"/><meta property="og:title" content="Design · RetrievalToolbox.jl"/><meta property="twitter:title" content="Design · RetrievalToolbox.jl"/><meta name="description" content="Documentation for RetrievalToolbox.jl."/><meta property="og:description" content="Documentation for RetrievalToolbox.jl."/><meta property="twitter:description" content="Documentation for RetrievalToolbox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RetrievalToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Main</a></li><li class="is-active"><a class="tocitem" href>Design</a><ul class="internal"><li><a class="tocitem" href="#Namespace"><span>Namespace</span></a></li><li><a class="tocitem" href="#Reliance-on-Julia-types"><span>Reliance on Julia types</span></a></li><li><a class="tocitem" href="#Buffers-for-performance"><span>Buffers for performance</span></a></li><li><a class="tocitem" href="#Executing-the-forward-model-will-mutate-some-objects"><span>Executing the forward model will mutate some objects</span></a></li><li><a class="tocitem" href="#Explicit-and-lengthy-or-simplified-and-short?"><span>Explicit and lengthy or simplified and short?</span></a></li><li><a class="tocitem" href="#Wrapper-functions-and-specific-dispatch"><span>Wrapper functions and specific dispatch</span></a></li><li><a class="tocitem" href="#Considering-quantities-with-physical-units"><span>Considering quantities with physical units</span></a></li><li><a class="tocitem" href="#Wavelengths-and-wavenumbers"><span>Wavelengths and wavenumbers</span></a></li><li><a class="tocitem" href="#Build-your-own-algorithm!"><span>Build your own algorithm!</span></a></li><li><a class="tocitem" href="#Extend-the-toolkit-with-your-own-types-and-functions"><span>Extend the toolkit with your own types and functions</span></a></li></ul></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../../concepts/core_concepts/">Core Concepts</a></li><li><a class="tocitem" href="../../concepts/radiance/">Radiance</a></li><li><a class="tocitem" href="../../concepts/phasefunction/">Scattering Phasefunction</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../functions/state_vector_functions/">State Vector Functions</a></li></ul></li><li><span class="tocitem">Types</span><ul><li><a class="tocitem" href="../../types/buffer_types/">Buffer Types</a></li><li><a class="tocitem" href="../../types/state_vector_types/">State Vector Types</a></li></ul></li><li><span class="tocitem">Working with Julia</span><ul><li><a class="tocitem" href="../../julia/develop/">Develop</a></li><li><a class="tocitem" href="../../julia/dicts/">Dictionaries</a></li><li><a class="tocitem" href="../../julia/units/">Units</a></li></ul></li><li><span class="tocitem">Pitfalls</span><ul><li><a class="tocitem" href="../../pitfalls/pitfalls/">Pitfalls</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Toolkit-design-philosophy"><a class="docs-heading-anchor" href="#Toolkit-design-philosophy">Toolkit design philosophy</a><a id="Toolkit-design-philosophy-1"></a><a class="docs-heading-anchor-permalink" href="#Toolkit-design-philosophy" title="Permalink"></a></h1><h2 id="Namespace"><a class="docs-heading-anchor" href="#Namespace">Namespace</a><a id="Namespace-1"></a><a class="docs-heading-anchor-permalink" href="#Namespace" title="Permalink"></a></h2><p>The RetrievalToolbox module exports many functions, types and variables - some of those might share names with functions from other modules or your own user code. While not strictly necessary, we generally recommend to load the module and then declare an alias to then call the module functions through it.</p><pre><code class="language-julia hljs">using RetrievalToolbox
const RE = RetrievalToolbox

RE.some_function()

# this, however, works too
some_function()</code></pre><h2 id="Reliance-on-Julia-types"><a class="docs-heading-anchor" href="#Reliance-on-Julia-types">Reliance on Julia types</a><a id="Reliance-on-Julia-types-1"></a><a class="docs-heading-anchor-permalink" href="#Reliance-on-Julia-types" title="Permalink"></a></h2><p>One of Julia&#39;s most prominent features is the flexibility that comes with its <a href="https://docs.julialang.org/en/v1/manual/types/">rich type system</a>. While not object-oriented in the sense that C++ is, objects, their relationship to functions, and how they act on specific objects is a major design component of Julia and thus RetrievalToolbox.</p><p>RetrievalToolbox defines a number of abstract types and then lots of composite types, which are akin to <code>struct</code> types in C. They usually sit below abstract types in the type hierarchy and represent some granular concept that is useful for trace gas retrievals.</p><p>For example, the <code>GaussAerosol</code> type belongs to the <code>AbstractAerosolType</code> which itself belongs to <code>AbstractAtmosphereElement</code>, and describes some aerosol whose vertical distribution in the model atmosphere is described by a Gaussian. The full type hierarchy here is <code>GaussAerosol ⊂ AbstractAerosolType ⊂ AbstractAtmosphereElement</code>. When users create a model atmosphere, they must add some <code>AbstractAtmosphereElement</code> to the list of atmosphere elements. At that stage, we do not care what <em>specific</em> object that might be, as long as it satisfies the requirement that it has to be a type that is a subtype of <code>AbstractAtmosphereElement</code>.</p><p>Now how does Julia&#39;s type system and the <strong>multiple dispatch</strong> paradigm help us here. First, it allows for some convenience. We can use some list of atmospheric elements that we want represented in our model atmosphere: aerosols and Rayleigh scattering. Those two are quite different in practical terms, even though they might act in similar ways on our various calculations. So if we have some list of <code>AbstractAtmosphereElement</code> objects</p><pre><code class="language-julia hljs">atm_list = [aerosol1, aerosol2, RayleighScattering()]</code></pre><p>we would ideally want to perform some action with each of those elements, such as calculating their contribution to the optical depth profiles of our model atmosphere. Some naïve way of doing that would be to iterate through each element and perform the appropriate action:</p><pre><code class="language-julia hljs">for atm in atm_list
    if is_an_aerosol(atm)
        tau = calculate_gauss_aerosol_tau(atm)
    end

    if is_Rayleigh_scattering(atm)
        tau = calculate_Rayleigh_tau(atm)
    end

    # .. do something with tau
end</code></pre><p>This is easily done with Julia, but makes this top-level iteration not very elegant. One can imagine that if we implement several aerosol distribution types, this loop will grow since we want to call the dedicated function to perform the wanted operation. The preferred way in Julia is making use of multiple dispatch: we decide on a name for a function that shall perform the equivalent task for different types. Let us call this function <code>calculate_tau</code>:</p><pre><code class="language-julia hljs">for atm in atm_list
    tau = calculate_tau(atm)
    # .. do something with tau
end</code></pre><p>and as long as there is a function <code>calculate_tau</code> which implements the calculate for the requested type, above code will execute and keep this top-level loop nice and tidy.</p><p>While the above example allows for some convenience, the strength of multiple dispatch also lies in how users can expand code without having to change code deep within a module they use. For example, let us imagine a new aerosol type that a user wants to integrate in their retrieval application: <code>MyAerosolType</code>. A new list of atmosphere elements would be created, like so</p><pre><code class="language-julia hljs">my_new_aerosol = MyAerosolType()
atm_list = [aerosol1, aerosol2, RayleighScattering(), my_new_aerosol()]</code></pre><p>Now in this imagined scenario, the user can now create their own <code>calculate_tau</code> function, which would implement the specific routine that computes the optical depth profiles for their new aerosol type:</p><pre><code class="language-julia hljs">function calculate_tau(a::MyAerosolType)
    # Do many calculations here...
    # ...
end</code></pre><p>When done correctly, the new function will be invoked when the loop above runs (<code>for atm in atm_list ...</code>)  since the Julia compiler will now look for a <code>calculate_tau</code> function that can act on an object of type <code>MyAerosolType</code>.</p><p>To summarize: RetrievalToolbox makes extensive use of Julia&#39;s type system such that many functions in the module do not act on primitive types (like numbers or strings), but on custom composite types.</p><div class="admonition is-info" id="Info-e79defe47f05abc5"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-e79defe47f05abc5" title="Permalink"></a></header><div class="admonition-body"><p>The Julia type system allows for flexibility in creating program code that looks the same for a variety of object types. Further, users can more easily extend existing code with their own types without necessarily having to change the underlying routines, but by providing their own user code.</p></div></div><h2 id="Buffers-for-performance"><a class="docs-heading-anchor" href="#Buffers-for-performance">Buffers for performance</a><a id="Buffers-for-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Buffers-for-performance" title="Permalink"></a></h2><p>Julia is a garbage-collected language (more detailed info <a href="https://docs.julialang.org/en/v1/devdocs/gc/">here</a>), meaning that users do not have explicit control over how and when objects are de-allocated from memory. When users write functions that allocate (by creating vectors and arrays, for example), the memory is not immediately freed when the function is completed. The garbage collector (GC) is triggered at some point when the memory usage reaches some level. The GC then traces through the objects in memory and removes those that are no longer used.</p><p>The big advantage of GC-based languages is of course that manual memory management is no longer needed, and users do not have to keep track of correct allocation and de-allocation of objects, and memory safety issues are also less common. The major downside is that without manual memory management, users could (un)willingly write code that very inefficiently allocates a lot of memory. When those allocations happen in certain places (loops mostly), memory will fill up quickly and trigger GC sweeps very often. The paradigm within Julia is usually: allocate arrays and vectors beforehand, and perform calculations on these pre-allocated objects.</p><p>Early versions of RetrievalToolbox did not make use of much pre-allocation, and most calls to functions would create new objects. This has proven to be not a feasible solution. While convenient for top-level scripting, the many allocations needed made it impossible to run faster retrievals where the forward model run was much less than a second (e.g. physics-based SIF retrievals or other non-scattering applications).</p><p>Thus, we make use of pre-allocated objects, which we call buffers here.</p><h3 id="Order-of-instantiation-in-a-retrieval-algorithm"><a class="docs-heading-anchor" href="#Order-of-instantiation-in-a-retrieval-algorithm">Order of instantiation in a retrieval algorithm</a><a id="Order-of-instantiation-in-a-retrieval-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-instantiation-in-a-retrieval-algorithm" title="Permalink"></a></h3><h2 id="Executing-the-forward-model-will-mutate-some-objects"><a class="docs-heading-anchor" href="#Executing-the-forward-model-will-mutate-some-objects">Executing the forward model will mutate some objects</a><a id="Executing-the-forward-model-will-mutate-some-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-the-forward-model-will-mutate-some-objects" title="Permalink"></a></h2><p>Kinda bad for e.g. gas scale factors that mean factors of some initial atmospheric state.</p><h2 id="Explicit-and-lengthy-or-simplified-and-short?"><a class="docs-heading-anchor" href="#Explicit-and-lengthy-or-simplified-and-short?">Explicit and lengthy or simplified and short?</a><a id="Explicit-and-lengthy-or-simplified-and-short?-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-and-lengthy-or-simplified-and-short?" title="Permalink"></a></h2><p>Explain why some code sections look explicitly verbose and long, and why making it shorter and less verbose is an option - sometimes.</p><h2 id="Wrapper-functions-and-specific-dispatch"><a class="docs-heading-anchor" href="#Wrapper-functions-and-specific-dispatch">Wrapper functions and specific dispatch</a><a id="Wrapper-functions-and-specific-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-functions-and-specific-dispatch" title="Permalink"></a></h2><h2 id="Considering-quantities-with-physical-units"><a class="docs-heading-anchor" href="#Considering-quantities-with-physical-units">Considering quantities with physical units</a><a id="Considering-quantities-with-physical-units-1"></a><a class="docs-heading-anchor-permalink" href="#Considering-quantities-with-physical-units" title="Permalink"></a></h2><p>Explain types and dedicated type fields for units. Pay attention to supplying quantities with the right units!</p><h2 id="Wavelengths-and-wavenumbers"><a class="docs-heading-anchor" href="#Wavelengths-and-wavenumbers">Wavelengths and wavenumbers</a><a id="Wavelengths-and-wavenumbers-1"></a><a class="docs-heading-anchor-permalink" href="#Wavelengths-and-wavenumbers" title="Permalink"></a></h2><p>RetrievalToolbox supports two fundamental spectral unit types: wavelength and wavenumber. Users might want to build an algorithm pipeline that is specific to some instrument, which natively produces spectra in either wavelength or wavenumber units. In order to make the native spectral unit be visible as such, RetrievalToolbox provides dynamic accessors which allow users to reference the spectral unit of objects using their natural wording or symbol.</p><p>Rather than writing duplicate types and functions, RetrievalToolbox employs <em>magic accessor</em> methods. Any quantity that represents a spectral unit, is typed <code>ww</code> or, for example, <code>ww_unit</code> or <code>ww_reference</code>. The two-letter combination <code>ww</code> is thus reserved in the RetrievalToolbox codebase, and no type fields should contain this combination of letters.</p><p>The <code>ww</code> should be considered a placeholder, which represents either a wavelength- or a wavenumber-related quantity. Any type that contains a field or quantity <code>ww</code> must also contain a field named <code>ww_unit</code>. Other fields are optional.</p><p>When the RetrievalToolbox module is imported, all types inside the RetrievalToolbox namespace are scanned for type fields that contain the substring <code>ww</code>. For each type that contains such a field, a new accessor function is dynamically created, which allows users to access the spectral type fields with the appropriate symbol. Illustrative examples follow.</p><p>Creating a spectral window object from 1.49 µm through 1.55 µm with 10 nm spacing could, for example, look like this (with loaded <code>Unitful</code>):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; swin = RE.SpectralWindow(
           &quot;test&quot;,
           1.49, # Lower limit
           1.55, # Upper limit
           collect(1.48:0.01:1.56), # Create the grid with spacing
           Unitful.µm, # Designate microns as unit of choice
           1.50 # Set some reference wavelength
           )</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `Unitful` not defined in `Main`
Suggestion: check for spelling errors or missing imports.
Hint: Unitful is loaded but not imported in the active module Main.</code></pre><p>As can be seen in the type definition, the spectral grid can be accessed via <code>swin.ww_grid</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; swin.ww_grid;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `swin` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(swin.ww_grid&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `swin` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>Now the magic accessor allows users to access the same field using the more &quot;natural&quot; wavelength term</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; swin.wavelength_grid;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `swin` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(swin.wavelength_grid&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `swin` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>or even the Unicode symbol λ:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; swin.λ_grid;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `swin` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(swin.λ_grid&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `swin` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>Note that <code>swin.λ_grid</code> or <code>swin.wavelength_grid</code> do not perform a calculation or conversion. For the spectral window type <code>SpectralWindow</code>, an overloaded <code>getproperty</code> function was dynamically created during startup such that <code>getproperty(SpectralWindow, :λ)</code> returns the <code>ww_grid</code> field, and similarly for wavenumber units.</p><p>Since types with some spectral dimension must also have a corresponding unit field, <code>ww_unit</code>, the <code>getproperty</code> function is able to check whether the requested spectral unit is appropriate. Trying to access <code>swin.wavenumber_grid</code> or <code>swin.ν_grid</code> will fail:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; swin.wavenumber_grid # or swin.ν</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `swin` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code></pre><p>Benchmarks have shown there is no significant performance drawback due to the use of the new <code>getproperty</code> functions.</p><p>When writing new functions that use objects of any types with a spectral unit, users can interrogate the <code>ww_unit</code> field to control the behavior of calculations. Inside RetrievalToolbox, this is done, for example, for the Doppler shift calculations, which use different expressions depending on whether they are performed in wavelength or wavenumber space.</p><pre><code class="language-julia hljs">function something_new(swin::RE.SpectralWindow)

    if swin.ww_unit isa Unitful.LengthUnit
        # Do calculations in wavelength space
    elseif swin.ww_unit isa Unitful.WavenumberUnit
        # Do calculations in wavenumber space
    end

end</code></pre><p>When users write functions, they should be mindful of when they use <code>.ww_grid</code> compared to <code>.wavelength_grid</code> or <code>.wavenumber_grid</code>. For many calculations, it makes no difference whether the spectral unit is wavelength or wavenumber, and thus writing <code>.ww</code> is legible and reasonable. If some function only makes sense in one spectral unit, but not in the other, then <code>.wavenumber_grid</code> or <code>.wavelength_grid</code> can be used. Note that in this case, an error will be thrown if an object with the wrong spectral unit is passed into this function, and the spectral unit will be accessed via <code>.wavenumber_grid</code> or <code>.wavelength_grid</code>. This might be the desired behavior - calculations should throw an error if invoked in the wrong spectral unit space.</p><p>When users write top-level retrieval scripts for some specific scenario, it is usually most obvious to write the specific spectral unit, as that does not change and it also becomes clear that only that specific spectral unit is considered. I.e., a retrieval script that launches OCO-2 retrievals should access the spectral unit with <code>.wavelength_grid</code>.</p><h2 id="Build-your-own-algorithm!"><a class="docs-heading-anchor" href="#Build-your-own-algorithm!">Build your own algorithm!</a><a id="Build-your-own-algorithm!-1"></a><a class="docs-heading-anchor-permalink" href="#Build-your-own-algorithm!" title="Permalink"></a></h2><h3 id="Custom-forward-model"><a class="docs-heading-anchor" href="#Custom-forward-model">Custom forward model</a><a id="Custom-forward-model-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-forward-model" title="Permalink"></a></h3><h3 id="Lack-of-an-instrument-type"><a class="docs-heading-anchor" href="#Lack-of-an-instrument-type">Lack of an instrument type</a><a id="Lack-of-an-instrument-type-1"></a><a class="docs-heading-anchor-permalink" href="#Lack-of-an-instrument-type" title="Permalink"></a></h3><h3 id="Custom-ingestion-of-needed-inputs"><a class="docs-heading-anchor" href="#Custom-ingestion-of-needed-inputs">Custom ingestion of needed inputs</a><a id="Custom-ingestion-of-needed-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-ingestion-of-needed-inputs" title="Permalink"></a></h3><h2 id="Extend-the-toolkit-with-your-own-types-and-functions"><a class="docs-heading-anchor" href="#Extend-the-toolkit-with-your-own-types-and-functions">Extend the toolkit with your own types and functions</a><a id="Extend-the-toolkit-with-your-own-types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Extend-the-toolkit-with-your-own-types-and-functions" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Main</a><a class="docs-footer-nextpage" href="../../concepts/core_concepts/">Core Concepts »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 11 August 2025 13:53">Monday 11 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
